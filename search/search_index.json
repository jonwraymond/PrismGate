{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PrismGate Documentation","text":"<p>PrismGate (gatemini) is a Rust MCP gateway that connects to 30+ backend MCP servers and exposes 7 meta-tools to AI agents via a shared daemon architecture.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Discovering tools: Tool Discovery -- progressive disclosure workflow</li> <li>Adding backends: Backend Management -- stdio/HTTP lifecycle</li> <li>Understanding token savings: Token Efficiency -- measured 82-98% reduction</li> <li>Configuration: Secrets &amp; Config -- YAML pipeline, hot-reload, BWS</li> </ul>"},{"location":"#documentation-index","title":"Documentation Index","text":""},{"location":"#core-architecture","title":"Core Architecture","text":"Document Description Architecture IPC daemon/proxy model, Unix socket coordination, process lifecycle Tool Discovery Progressive disclosure, BM25+semantic hybrid search, brief/full modes Token Efficiency Measured savings with real data, comparison tables, industry benchmarks Sandbox V8 <code>call_tool_chain</code> execution, bridge preamble, direct parsing fast path"},{"location":"#operations","title":"Operations","text":"Document Description Backend Management Health checks, circuit breaker, auto-restart, stdio/HTTP backends Secrets &amp; Config Secret resolution pipeline, config hot-reload, Bitwarden integration Resources &amp; Prompts MCP resources for @-mention discovery, guided workflow prompts Telemetry Strategy OpenTelemetry integration plan with GenAI semantic conventions"},{"location":"#benchmarks","title":"Benchmarks","text":"Document Description Search Quality BM25+semantic validation at scale, RRF fusion analysis Token Savings Real measurements, before/after comparisons, test methodology"},{"location":"#references","title":"References","text":"Document Description MCP Best Practices 34+ curated external sources on tool design, naming, progressive disclosure Competing Gateways Kong, Envoy, Microsoft, Lasso, IBM architecture comparison"},{"location":"#building","title":"Building","text":"<pre><code>cargo build                    # debug build\ncargo build --release          # release build (includes V8 sandbox + semantic search)\ncargo test                     # run unit tests\n</code></pre>"},{"location":"#source-code-map","title":"Source Code Map","text":"<p>See CLAUDE.md for the complete module reference table.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>PrismGate uses a shared daemon model to multiplex backend MCP servers across multiple AI agent sessions. A single daemon process manages all backends, while lightweight proxy processes bridge each Claude Code session's stdio to the daemon via Unix domain sockets.</p>"},{"location":"architecture/#process-model","title":"Process Model","text":"<pre><code>Claude Code \u2500\u2500stdio\u2500\u2500\u25b8 gatemini (proxy) \u2500\u2500\u2510\nClaude Code \u2500\u2500stdio\u2500\u2500\u25b8 gatemini (proxy) \u2500\u2500\u2524 Unix socket\nClaude Code \u2500\u2500stdio\u2500\u2500\u25b8 gatemini (proxy) \u2500\u2500\u2518 /tmp/gatemini-{UID}.sock\n                                           \u2502\n                                    gatemini daemon (1 process)\n                                      \u251c\u2500\u2500 backend MCP server #1 (stdio child)\n                                      \u251c\u2500\u2500 backend MCP server #2 (stdio child)\n                                      \u251c\u2500\u2500 backend MCP server #3 (HTTP)\n                                      \u2514\u2500\u2500 ... (30+ backends, shared)\n</code></pre> <p>This architecture delivers three key benefits:</p> <ol> <li>Resource sharing -- 30+ backend processes run once, shared across all Claude Code sessions</li> <li>Instant startup -- proxy connects to existing daemon in ~2s; no backend initialization per session</li> <li>Independent lifecycle -- daemon survives client disconnects; auto-shuts down after 5 minutes idle</li> </ol>"},{"location":"architecture/#proxy-mode","title":"Proxy Mode","text":"<p>Source: <code>src/ipc/proxy.rs</code></p> <p>The proxy is a zero-initialization byte pipe. It performs no config loading, no tracing setup, and no backend management. Its sole job is bridging Claude Code's stdio to the daemon's Unix socket.</p>"},{"location":"architecture/#startup-sequence","title":"Startup Sequence","text":"<pre><code>1. cleanup_stale_socket()\n   \u2514\u2500 If socket exists but daemon is dead \u2192 remove stale socket + PID file\n\n2. try_connect() [2s timeout]\n   \u2514\u2500 Success \u2192 bridge_stdio() \u2192 done (fast path)\n\n3. try_acquire_lock() [exclusive flock on .lock file]\n   \u251c\u2500 Won lock:\n   \u2502   \u251c\u2500 Double-check: try_connect() again (race protection)\n   \u2502   \u251c\u2500 spawn_daemon() as detached child (stdin/stdout null, stderr inherit)\n   \u2502   \u2514\u2500 wait_for_socket() [exponential backoff: 50ms\u21921s, 30s timeout]\n   \u2514\u2500 Lock held by another proxy:\n       \u2514\u2500 wait_for_socket() [another proxy is already spawning]\n\n4. bridge_stdio()\n   \u2514\u2500 Bidirectional: stdin\u2192socket, socket\u2192stdout\n   \u2514\u2500 Exits on either EOF or BrokenPipe\n</code></pre>"},{"location":"architecture/#flock-double-check-pattern","title":"Flock + Double-Check Pattern","text":"<p>When multiple Claude Code sessions start simultaneously, only one proxy should spawn the daemon. PrismGate uses a file lock with double-checking:</p> <ol> <li>First check: <code>try_connect()</code> -- most common path, daemon already running</li> <li>Acquire exclusive flock on <code>{socket_path}.lock</code> -- non-blocking, fails if held</li> <li>Second check: <code>try_connect()</code> again -- another proxy may have just finished spawning</li> <li>Spawn if needed: only the lock holder spawns; others wait for the socket</li> </ol> <p>The lock is held throughout daemon spawning and released after the socket becomes connectable. This prevents duplicate daemon instances without polling or retry loops.</p>"},{"location":"architecture/#daemon-spawning","title":"Daemon Spawning","text":"<p>The proxy spawns itself with the <code>serve</code> subcommand:</p> <pre><code>gatemini -c /path/to/config.yaml serve\n</code></pre> <ul> <li><code>stdin</code>/<code>stdout</code> set to <code>Stdio::null()</code> -- daemon doesn't hold proxy's stdio</li> <li><code>stderr</code> inherited -- daemon logs via tracing appear in the terminal</li> <li>Process is detached -- proxy can exit without killing the daemon</li> </ul>"},{"location":"architecture/#daemon-mode","title":"Daemon Mode","text":"<p>Source: <code>src/ipc/daemon.rs</code></p> <p>The daemon is the heavyweight process that manages all backend MCP servers. It initializes once and serves multiple clients concurrently.</p>"},{"location":"architecture/#initialization-shared-with-all-modes","title":"Initialization (shared with all modes)","text":"<p>Source: <code>src/main.rs</code> -- <code>initialize()</code></p> <pre><code>1. load_dotenv()           -- Load ~/.env (Once pattern, thread-safe)\n2. Load config             -- shellexpand \u2192 YAML parse\n3. Initialize tracing      -- Structured logging to stderr\n4. resolve_secrets_async   -- Resolve secretref: patterns\n5. Create ToolRegistry     -- With or without EmbeddingIndex\n6. Create BackendManager   -- DashMap-backed concurrent store\n7. Load tool cache         -- Instant tool availability from previous run\n8. Spawn background tasks:\n   \u251c\u2500\u2500 start_all()         -- Connect all backends, discover tools\n   \u251c\u2500\u2500 health_checker()    -- Periodic pings, circuit breaker\n   \u251c\u2500\u2500 watch_config()      -- File watcher for hot-reload\n   \u2514\u2500\u2500 admin_api()         -- Optional HTTP admin (feature-gated)\n</code></pre>"},{"location":"architecture/#accept-loop","title":"Accept Loop","text":"<p>After initialization, the daemon binds the Unix socket and enters the accept loop:</p> <pre><code>loop {\n    select! {\n        accept = listener.accept() =&gt; { /* spawn client task */ }\n        () = idle_sleep, if idle_enabled &amp;&amp; active_sessions == 0 =&gt; { break; }\n        _ = sigterm.recv() =&gt; { break; }\n        _ = sigint.recv() =&gt; { break; }\n    }\n}\n</code></pre> <p>Each connected client gets a new <code>GateminiServer</code> instance (cheap: clones <code>Arc</code> references to the shared registry and backend manager). The rmcp crate handles the full MCP protocol per session.</p> <p>Key concurrency primitives:</p> Primitive Purpose <code>TaskTracker</code> Tracks active client tasks for graceful shutdown <code>AtomicUsize</code> Counts active sessions for idle timeout <code>Arc&lt;Notify&gt;</code> Broadcasts shutdown signal to background tasks"},{"location":"architecture/#idle-shutdown","title":"Idle Shutdown","text":"<p>The daemon exits after <code>idle_timeout</code> (default 5 minutes) with zero active clients:</p> <ul> <li>Timer resets on every new client connection</li> <li>Timer is pushed forward while any client is connected</li> <li>The proxy auto-restarts the daemon on next use</li> </ul>"},{"location":"architecture/#graceful-shutdown-sequence","title":"Graceful Shutdown Sequence","text":"<pre><code>1. Stop accepting new connections (break accept loop)\n2. client_tracker.close() + wait() -- drain active client sessions\n3. shutdown_notify.notify_waiters() -- signal background tasks\n4. backend_manager.stop_all() -- stop all backends, wait for in-flight calls\n5. socket::cleanup_files() -- remove socket + PID file\n</code></pre>"},{"location":"architecture/#socket-coordination","title":"Socket Coordination","text":"<p>Source: <code>src/ipc/socket.rs</code></p>"},{"location":"architecture/#path-determination","title":"Path Determination","text":"<pre><code>/tmp/gatemini-{UID}.sock          -- socket\n/tmp/gatemini-{UID}.sock.pid      -- PID file\n/tmp/gatemini-{UID}.sock.lock     -- flock coordination\n</code></pre> <p>On Linux with <code>$XDG_RUNTIME_DIR</code>, the base path uses that instead of <code>/tmp</code>. The UID suffix ensures multi-user isolation on shared machines.</p>"},{"location":"architecture/#liveness-check","title":"Liveness Check","text":"<p><code>is_daemon_alive()</code> reads the PID file and sends signal 0:</p> <pre><code>libc::kill(pid as libc::pid_t, 0)  // 0 = no signal, just check existence\n</code></pre> <p>Returns <code>true</code> if the process exists and belongs to the current user.</p>"},{"location":"architecture/#lock-acquisition","title":"Lock Acquisition","text":"<p><code>try_acquire_lock()</code> uses <code>flock(LOCK_EX | LOCK_NB)</code>:</p> <ul> <li>Non-blocking: returns immediately if another process holds the lock</li> <li>File descriptor ownership: lock auto-releases if the process crashes</li> <li>Deliberate retention: lock file is never deleted (it's the coordination mechanism)</li> </ul>"},{"location":"architecture/#status-and-stop-commands","title":"Status and Stop Commands","text":"<p>Sources: <code>src/ipc/status.rs</code>, <code>src/ipc/stop.rs</code></p> Command Action <code>gatemini status</code> Read PID file, check if alive via signal 0, print status <code>gatemini stop</code> Send SIGTERM to daemon PID, poll for exit (100ms intervals, 5s timeout)"},{"location":"architecture/#process-group-isolation","title":"Process Group Isolation","text":"<p>Source: <code>src/backend/stdio.rs</code></p> <p>Each stdio backend spawns with <code>process_group(0)</code>, creating a new process group:</p> <pre><code>cmd.process_group(0)  // setsid-like: child gets its own PGID = PID\n</code></pre> <p>On termination, PrismGate sends SIGTERM to the entire process group:</p> <pre><code>libc::kill(-(pid as i32), libc::SIGTERM)  // negative PID = process group\n</code></pre> <p>This ensures the backend and all its children (subprocesses, scripts) are terminated together. Without process groups, killing the parent would orphan children to init.</p>"},{"location":"architecture/#termination-sequence","title":"Termination Sequence","text":"<pre><code>1. SIGTERM to process group: kill(-(pid), SIGTERM)\n2. Wait 200ms for graceful exit\n3. Force kill child: child.kill() as fallback\n</code></pre>"},{"location":"architecture/#transport-performance","title":"Transport Performance","text":"<p>PrismGate chose Unix domain sockets over TCP for proxy-daemon IPC:</p> Metric Unix Socket TCP Localhost Latency ~2-3 us ~3.6 us Throughput (100B msg) 130k msg/s 70k msg/s Overhead Kernel bypass Full TCP/IP stack <p>Benchmarks from Baeldung IPC comparison. UDS avoids TCP checksum, congestion control, and routing overhead. The tradeoff is local-machine only -- which is exactly PrismGate's deployment model.</p>"},{"location":"architecture/#three-operating-modes","title":"Three Operating Modes","text":"Mode Command Use Case Proxy (default) <code>gatemini</code> Claude Code integration via stdio Daemon <code>gatemini serve</code> Started automatically by proxy; can also run standalone Direct <code>gatemini --direct</code> Single-session mode, no daemon/socket (debugging)"},{"location":"architecture/#sources","title":"Sources","text":"<ul> <li><code>src/ipc/proxy.rs</code> -- Proxy mode implementation</li> <li><code>src/ipc/daemon.rs</code> -- Daemon accept loop and shutdown</li> <li><code>src/ipc/socket.rs</code> -- Socket path, PID, flock coordination</li> <li><code>src/main.rs</code> -- Initialization and mode dispatch</li> <li>rmcp -- Rust MCP SDK used for protocol handling</li> <li>Baeldung IPC Performance -- UDS vs TCP benchmarks</li> <li>flock(2) man page -- File locking semantics</li> <li>Process group kill semantics -- kill(-pgid)</li> </ul>"},{"location":"backend-management/","title":"Backend Management","text":"<p>PrismGate manages 30+ backend MCP servers through a concurrent lifecycle system with health monitoring, circuit breaking, and automatic recovery.</p> <p></p>"},{"location":"backend-management/#backendmanager","title":"BackendManager","text":"<p>Source: <code>src/backend/mod.rs</code></p> <p>The <code>BackendManager</code> is the central authority for backend lifecycle:</p> <pre><code>struct BackendManager {\n    backends: Arc&lt;DashMap&lt;String, Arc&lt;dyn Backend&gt;&gt;&gt;,  // Running backends\n    configs: RwLock&lt;HashMap&lt;String, BackendConfig&gt;&gt;,    // All backend configs\n    in_flight_calls: AtomicUsize,                       // Global call counter\n    dynamic_backends: RwLock&lt;HashSet&lt;String&gt;&gt;,           // Runtime-registered\n    prerequisite_pids: DashMap&lt;String, u32&gt;,             // Managed prerequisites\n}\n</code></pre>"},{"location":"backend-management/#why-dashmap","title":"Why DashMap?","text":"<p><code>DashMap</code> provides lock-free concurrent reads through internal sharding (one shard per CPU core, each with an independent <code>RwLock</code>). Multiple backends can register tools simultaneously at startup without contention. This is critical during initialization when 30+ backends connect and discover tools concurrently.</p>"},{"location":"backend-management/#backend-trait","title":"Backend Trait","text":"<p>All backends implement a common trait:</p> Method Purpose <code>start()</code> Spawn process / connect to HTTP endpoint, perform MCP handshake <code>stop()</code> Graceful shutdown, terminate child process <code>call_tool(name, args)</code> Forward tool call to the backend <code>discover_tools()</code> List available tools via MCP <code>is_available()</code> Quick state check (non-blocking) <code>state()</code> Current state: Starting, Healthy, Unhealthy, Stopped <code>wait_for_exit()</code> Monitor child process for unexpected exit (stdio only)"},{"location":"backend-management/#stdio-backends","title":"Stdio Backends","text":"<p>Source: <code>src/backend/stdio.rs</code></p> <p>Stdio backends are MCP servers spawned as child processes communicating over stdin/stdout.</p>"},{"location":"backend-management/#spawn-and-handshake","title":"Spawn and Handshake","text":"<pre><code>1. tokio::process::Command::new(command)\n   \u251c\u2500 .args(args)\n   \u251c\u2500 .envs(env)                     -- Resolved secrets injected here\n   \u251c\u2500 .stdin(Stdio::piped())\n   \u251c\u2500 .stdout(Stdio::piped())\n   \u251c\u2500 .stderr(Stdio::inherit())      -- Backend logs visible in daemon stderr\n   \u2514\u2500 .process_group(0)              -- New process group for clean termination\n\n2. rmcp handshake: ().serve((stdout, stdin))\n   \u2514\u2500 MCP initialize \u2192 peer_info (server_name, version)\n\n3. Spawn reaper task (monitors for unexpected exit)\n</code></pre>"},{"location":"backend-management/#process-termination","title":"Process Termination","text":"<pre><code>// Step 1: SIGTERM to process group (child + all its children)\nlibc::kill(-(pid as i32), libc::SIGTERM);\n\n// Step 2: Wait 200ms for graceful exit\ntokio::time::sleep(Duration::from_millis(200)).await;\n\n// Step 3: Force kill as fallback\nchild.kill().await;\n</code></pre> <p>Process group isolation (<code>process_group(0)</code>) ensures that if a backend spawns subprocesses (e.g., Node.js spawning worker threads), they're all terminated together. Without this, killing the parent would orphan children to init.</p>"},{"location":"backend-management/#reaper-task","title":"Reaper Task","text":"<p>Each stdio backend spawns a background task that monitors for unexpected exits:</p> <pre><code>async fn reaper(backend: Arc&lt;StdioBackend&gt;) {\n    backend.wait_for_exit().await;\n    // Mark as Stopped \u2014 health checker will auto-restart\n}\n</code></pre> <p>This provides immediate crash detection rather than waiting for the next health check interval.</p>"},{"location":"backend-management/#http-backends","title":"HTTP Backends","text":"<p>Source: <code>src/backend/http.rs</code></p> <p>HTTP backends connect to remote MCP servers via Streamable HTTP transport:</p> <pre><code>gatemini daemon \u2500\u2500HTTP\u2500\u2500\u25b8 remote MCP server\n                          (e.g., z.ai, custom HTTP servers)\n</code></pre>"},{"location":"backend-management/#lenientclient","title":"LenientClient","text":"<p>Source: <code>src/backend/lenient_client.rs</code></p> <p>Some MCP servers (notably z.ai) omit the <code>Content-Type</code> header in responses. PrismGate wraps the reqwest client to tolerate this, treating missing Content-Type as <code>application/json</code>.</p>"},{"location":"backend-management/#header-forwarding","title":"Header Forwarding","text":"<p>HTTP backends support <code>Authorization</code> and custom headers:</p> <pre><code>backends:\n  my_api:\n    transport: http\n    url: \"https://api.example.com/mcp\"\n    headers:\n      Authorization: \"Bearer secretref:bws:project/dotenv/key/MY_API_KEY\"\n      X-Custom: \"value\"\n</code></pre>"},{"location":"backend-management/#tool-call-forwarding","title":"Tool Call Forwarding","text":""},{"location":"backend-management/#callguard-raii-in-flight-tracking","title":"CallGuard (RAII In-Flight Tracking)","text":"<p>Every tool call is wrapped in a <code>CallGuard</code> that increments <code>in_flight_calls</code> on creation and decrements on drop:</p> <pre><code>let _guard = CallGuard::new(&amp;self.in_flight_calls);\n// ... execute tool call ...\n// Guard dropped here \u2192 counter decremented\n</code></pre> <p>This ensures accurate tracking even if the call panics or errors.</p>"},{"location":"backend-management/#retry-logic-for-starting-backends","title":"Retry Logic for Starting Backends","text":"<p>If a backend is in <code>Starting</code> state (connecting but not yet ready), tool calls retry with backoff:</p> Attempt Delay Total Wait 1 500ms 500ms 2 1s 1.5s 3 2s 3.5s <p>After 3 attempts, the call fails with an error. Backends in <code>Unhealthy</code> or <code>Stopped</code> states fail immediately (no retry).</p>"},{"location":"backend-management/#graceful-shutdown","title":"Graceful Shutdown","text":"<p><code>stop_all()</code> waits for all in-flight calls to complete before terminating backends:</p> <pre><code>1. Stop accepting new calls (mark all backends as Stopping)\n2. Wait for in_flight_calls.load() == 0\n3. Stop each backend (SIGTERM \u2192 force kill)\n4. Clean up prerequisite processes\n</code></pre>"},{"location":"backend-management/#health-checker","title":"Health Checker","text":"<p>Source: <code>src/backend/health.rs</code></p> <p>The health checker runs on a configurable interval (default 5s) and manages backend health through three phases:</p>"},{"location":"backend-management/#phase-1-ping-healthy-backends","title":"Phase 1: Ping Healthy Backends","text":"<ul> <li>Concurrent MCP ping requests to all <code>Healthy</code> backends</li> <li>Staggered across 80% of the interval to avoid thundering herd</li> <li>Configurable timeout per ping (default 10s)</li> </ul>"},{"location":"backend-management/#phase-2-handle-failed-backends","title":"Phase 2: Handle Failed Backends","text":"<p>For <code>Stopped</code> or <code>Unhealthy</code> backends:</p> <pre><code>Circuit open?\n  \u251c\u2500 Yes, within recovery window \u2192 Skip (circuit stays open)\n  \u251c\u2500 Yes, recovery window expired \u2192 Half-open probe\n  \u2502   \u251c\u2500 Probe succeeds \u2192 Circuit closed, mark Healthy\n  \u2502   \u2514\u2500 Probe fails \u2192 Reset circuit timer, stay open\n  \u2514\u2500 No \u2192 Auto-restart with exponential backoff\n</code></pre>"},{"location":"backend-management/#phase-3-retry-pending-backends","title":"Phase 3: Retry Pending Backends","text":"<p>Backends that failed initial handshake (config exists but never entered DashMap) are retried with the same backoff logic.</p>"},{"location":"backend-management/#circuit-breaker","title":"Circuit Breaker","text":"Parameter Default Purpose <code>failure_threshold</code> 3 Consecutive failures before circuit opens <code>max_restarts</code> 3 Maximum restarts per window <code>restart_window</code> 5 min Window for counting restarts <p>States:</p> <pre><code>Closed (Healthy)\n  \u2500\u2500 N consecutive failures \u2500\u2500\u25b8 Open (Unhealthy)\n                                  \u2500\u2500 3x check interval \u2500\u2500\u25b8 Half-Open\n                                                            \u251c\u2500 Probe OK \u2500\u2500\u25b8 Closed\n                                                            \u2514\u2500 Probe fail \u2500\u2500\u25b8 Open\n</code></pre>"},{"location":"backend-management/#exponential-backoff","title":"Exponential Backoff","text":"<p>Restart delay doubles with each attempt:</p> Attempt Delay 0 1s 1 2s 2 4s 3 8s 4 16s 5+ 30s (capped) <p>The restart window resets after <code>restart_window</code> (5 min) expires, allowing fresh restart attempts for transient failures.</p>"},{"location":"backend-management/#prerequisite-processes","title":"Prerequisite Processes","text":"<p>Source: <code>src/backend/prerequisite.rs</code></p> <p>Some backends require a prerequisite process (e.g., a local API server) before they can start:</p> <pre><code>backends:\n  vibe_kanban:\n    command: npx\n    args: [\"-y\", \"vibe-kanban-mcp\"]\n    prerequisite:\n      command: \"python3\"\n      args: [\"-m\", \"http.server\", \"8080\"]\n      process_match: \"http.server 8080\"  # pgrep pattern for dedup\n      managed: true                       # Stop on daemon shutdown\n      startup_delay: 2s                   # Wait before starting backend\n</code></pre>"},{"location":"backend-management/#deduplication","title":"Deduplication","text":"<p>Before spawning, PrismGate checks if the prerequisite is already running:</p> <pre><code>pgrep -f \"http.server 8080\"\n</code></pre> <p>If found, the spawn is skipped (idempotent). This prevents duplicate processes when the daemon restarts.</p>"},{"location":"backend-management/#lifecycle","title":"Lifecycle","text":"<ul> <li><code>managed: true</code> -- PrismGate sends SIGTERM to the process group on daemon shutdown</li> <li><code>managed: false</code> -- PrismGate leaves the process running (external management)</li> </ul>"},{"location":"backend-management/#runtime-registration","title":"Runtime Registration","text":"<p>Source: <code>src/tools/register.rs</code></p> <p>Backends can be added and removed at runtime via meta-tools:</p>"},{"location":"backend-management/#register_manual","title":"register_manual","text":"<pre><code>{\n  \"manual_call_template\": {\n    \"name\": \"my-backend\",\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"my-mcp-server\"],\n    \"env\": {\"API_KEY\": \"...\"}\n  }\n}\n</code></pre> <p>Validation: - Name must match <code>[a-zA-Z0-9][a-zA-Z0-9_-]{0,63}</code> - Dynamic backend limit enforced (default 10, prevents DoS) - Transport auto-detected: stdio if <code>command</code> present, HTTP if <code>url</code> present - All registrations logged for audit</p>"},{"location":"backend-management/#deregister_manual","title":"deregister_manual","text":"<ul> <li>Only dynamic (runtime-registered) backends can be removed</li> <li>Static config backends are protected from deregistration</li> <li>Distinguishes \"not found\" from \"static/protected\" in error messages</li> </ul>"},{"location":"backend-management/#sources","title":"Sources","text":"<ul> <li><code>src/backend/mod.rs</code> -- BackendManager and Backend trait</li> <li><code>src/backend/stdio.rs</code> -- Stdio backend lifecycle</li> <li><code>src/backend/http.rs</code> -- HTTP backend transport</li> <li><code>src/backend/health.rs</code> -- Health checker and circuit breaker</li> <li><code>src/backend/prerequisite.rs</code> -- Prerequisite processes</li> <li><code>src/tools/register.rs</code> -- Runtime registration</li> <li>DashMap -- Concurrent HashMap</li> <li>rmcp -- Rust MCP SDK</li> <li>AWS Circuit Breaker -- Pattern reference</li> <li>Azure Circuit Breaker -- Health check probing</li> <li>AWS Exponential Backoff -- Backoff with jitter</li> <li>Process group termination -- kill(-pgid)</li> </ul>"},{"location":"resources-and-prompts/","title":"Resources &amp; Prompts","text":"<p>PrismGate uses all three MCP primitives -- tools, resources, and prompts -- to provide multiple discovery pathways for AI agents.</p>"},{"location":"resources-and-prompts/#mcp-primitive-roles","title":"MCP Primitive Roles","text":"Primitive Control PrismGate Use Tools Model-controlled (AI decides when to call) 7 meta-tools for search, inspect, execute Resources Application-controlled (client loads via @-mention) Compact indices, on-demand schemas Prompts User-controlled (slash commands, menus) Guided discovery workflows <p>This separation follows the MCP specification: tools are for actions the AI initiates, resources are for data the application provides, and prompts are for user-initiated workflows.</p>"},{"location":"resources-and-prompts/#resources","title":"Resources","text":"<p>Source: <code>src/resources.rs</code></p>"},{"location":"resources-and-prompts/#static-resources","title":"Static Resources","text":"URI Tokens Content <code>gatemini://overview</code> ~500 Gateway guide: how to use meta-tools, discovery workflow, token savings tips <code>gatemini://backends</code> Variable JSON list of all backends with status and tool counts <code>gatemini://tools</code> ~3,000 Compact index of ALL tools (name, backend, first sentence) <p>The <code>gatemini://tools</code> resource is the flagship optimization: loading it provides awareness of all 258+ tools for ~3,000 tokens versus ~40,000 tokens for full schemas -- a 92.5% reduction.</p>"},{"location":"resources-and-prompts/#resource-templates","title":"Resource Templates","text":"URI Pattern Content On-Demand Cost <code>gatemini://tool/{tool_name}</code> Full schema for one tool 200-10,000 tokens <code>gatemini://backend/{backend_name}</code> Backend details, status, tool count ~200 tokens <code>gatemini://backend/{backend_name}/tools</code> Brief tool list for one backend Variable <p>Templates enable targeted lookups: instead of loading all 258 tool schemas, an agent can load the compact index and then request full schemas only for tools it intends to use.</p>"},{"location":"resources-and-prompts/#first-sentence-truncation","title":"First Sentence Truncation","text":"<p>Resources use a more aggressive 120-character truncation than discovery tools (200 characters) for maximum compactness:</p> <pre><code>// In resources.rs: 120 char limit\nfn first_sentence(text: &amp;str) -&gt; String { ... }\n\n// In discovery.rs: 200 char limit\nfn first_sentence(text: &amp;str) -&gt; String { ... }\n</code></pre>"},{"location":"resources-and-prompts/#resource-completions","title":"Resource Completions","text":"<p>PrismGate provides autocomplete for resource URI parameters:</p> <pre><code>gatemini://tool/web_     \u2192 [\"web_search_exa\", \"web_search_tavily\", ...]\ngatemini://backend/e     \u2192 [\"exa\"]\n</code></pre> <p>This enables IDE-like completion when constructing resource URIs.</p>"},{"location":"resources-and-prompts/#prompts","title":"Prompts","text":"<p>Source: <code>src/prompts.rs</code></p>"},{"location":"resources-and-prompts/#discover","title":"discover","text":"<p>A 4-step guided walkthrough teaching the progressive disclosure workflow:</p> <pre><code>Step 1: View available backends\n  \u2192 Load @gatemini://backends\n\nStep 2: Search for tools\n  \u2192 search_tools(\"your task\", brief=true) \u2014 ~60 tokens/result\n\nStep 3: Get full schema when ready to execute\n  \u2192 tool_info(\"tool_name\", detail=\"full\") \u2014 or load @gatemini://tool/{name}\n\nStep 4: Execute\n  \u2192 call_tool_chain('backend.tool_name({args})')\n</code></pre> <p>The prompt explicitly documents token savings: brief mode saves 80-98% tokens during discovery.</p>"},{"location":"resources-and-prompts/#find_tool","title":"find_tool","text":"<p>Takes a task description as input and automates the search workflow:</p> <ol> <li>Performs BM25 search for top 5 matches</li> <li>Displays results in a markdown table (name, backend, brief description)</li> <li>Includes the full schema for the top match</li> <li>Provides an executable TypeScript example:</li> </ol> <pre><code>const r = await backend.tool_name({param: \"value\"});\nreturn r;\n</code></pre>"},{"location":"resources-and-prompts/#backend_status","title":"backend_status","text":"<p>Generates a health dashboard showing all backends:</p> <pre><code>| Backend | Status | Tools | Transport |\n|---------|--------|-------|-----------|\n| exa | Healthy | 3 | stdio |\n| tavily | Healthy | 1 | stdio |\n| custom | Starting | 0 | http |\n</code></pre>"},{"location":"resources-and-prompts/#server-instructions","title":"Server Instructions","text":"<p>Source: <code>src/server.rs</code></p> <p>PrismGate embeds discovery instructions directly in its MCP <code>get_info()</code> response. These instructions are delivered to the AI agent before it makes any tool calls:</p> <pre><code>gatemini is an MCP gateway that aggregates tools from multiple backend MCP servers.\nUse search_tools to find tools, tool_info for details, and call_tool_chain to execute\nTypeScript code that calls backend tools.\n\n## Discovery Workflow (use progressive disclosure to save context)\n1. search_tools(\"your task\") \u2192 brief results by default (~60 tokens/result)\n2. tool_info(\"name\") \u2192 brief: name, backend, description, param names (~200 tokens)\n3. tool_info(\"name\", detail=\"full\") \u2192 complete schema, ONLY when ready to call\n4. call_tool_chain(\"code\") \u2192 execute TypeScript\n</code></pre> <p>This approach teaches agents the progressive disclosure pattern without requiring external documentation, and it works across all MCP clients (Claude Code, Cursor, etc.).</p>"},{"location":"resources-and-prompts/#when-to-use-each-primitive","title":"When to Use Each Primitive","text":""},{"location":"resources-and-prompts/#use-resources-when","title":"Use Resources When","text":"<ul> <li>Loading context at conversation start (e.g., <code>@gatemini://tools</code> for tool awareness)</li> <li>Agent needs static data that doesn't require a decision (backend list, tool schemas)</li> <li>Client supports @-mention syntax</li> </ul>"},{"location":"resources-and-prompts/#use-tools-when","title":"Use Tools When","text":"<ul> <li>Agent is searching for relevant tools (<code>search_tools</code>)</li> <li>Agent needs to inspect a specific tool (<code>tool_info</code>)</li> <li>Agent is executing an action (<code>call_tool_chain</code>)</li> </ul>"},{"location":"resources-and-prompts/#use-prompts-when","title":"Use Prompts When","text":"<ul> <li>User wants a guided walkthrough (<code>/discover</code>)</li> <li>User wants to find a tool interactively (<code>/find_tool</code>)</li> <li>User wants to check backend health (<code>/backend_status</code>)</li> </ul>"},{"location":"resources-and-prompts/#sources","title":"Sources","text":"<ul> <li><code>src/resources.rs</code> -- Resource implementation</li> <li><code>src/prompts.rs</code> -- Prompt implementations</li> <li><code>src/server.rs</code> -- Server instructions and MCP integration</li> <li>MCP Specification (2025-11-25) -- Official protocol spec</li> <li>MCP Resources -- Resource concept guide</li> <li>MCP Features Guide (WorkOS) -- Comprehensive feature overview</li> <li>Laurent Kubaski stdio transport -- Transport protocol</li> <li>CodeSignal MCP Primitives -- Primitive roles</li> </ul>"},{"location":"sandbox/","title":"Sandbox","text":"<p>PrismGate's <code>call_tool_chain</code> meta-tool lets AI agents execute TypeScript code that calls backend tools. This enables multi-tool orchestration (loops, conditionals, error handling) in a single execution context, reducing LLM round-trips and token usage.</p>"},{"location":"sandbox/#three-tier-execution-strategy","title":"Three-Tier Execution Strategy","text":"<p><code>call_tool_chain</code> uses a performance-optimized tiered approach:</p> <pre><code>Input code\n  \u251c\u2500 Tier 1: Direct JSON parsing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 O(1), no V8 overhead\n  \u251c\u2500 Tier 2: Simple TypeScript parsing \u2500\u2500 Regex-based, no V8 overhead\n  \u2514\u2500 Tier 3: V8 sandbox \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Full TypeScript execution\n</code></pre>"},{"location":"sandbox/#tier-1-direct-json-parsing","title":"Tier 1: Direct JSON Parsing","text":"<p>Source: <code>src/tools/sandbox.rs</code></p> <p>Detects pure JSON tool calls:</p> <pre><code>{\"tool\": \"exa.web_search_exa\", \"arguments\": {\"query\": \"MCP protocol\"}}\n</code></pre> <p>Parsed directly, dispatched to the backend, no V8 involved.</p>"},{"location":"sandbox/#tier-2-simple-typescript-parsing","title":"Tier 2: Simple TypeScript Parsing","text":"<p>Detects single-tool TypeScript patterns by stripping common boilerplate:</p> <pre><code>const result = await exa.web_search_exa({query: \"MCP protocol\"}); return result;\n</code></pre> <p>The parser strips <code>const result =</code>, <code>await</code>, <code>return result</code>, and semicolons to extract the core call pattern <code>backend.tool_name({args})</code>. This handles the vast majority of LLM-generated tool calls without V8 startup overhead.</p>"},{"location":"sandbox/#tier-3-v8-sandbox","title":"Tier 3: V8 Sandbox","text":"<p>Source: <code>src/sandbox/mod.rs</code></p> <p>For multi-step, conditional, or complex orchestration that can't be parsed as a simple call:</p> <pre><code>const results = await exa.web_search_exa({query: \"Rust MCP\"});\nconst urls = results.results.map(r =&gt; r.url);\nconst details = [];\nfor (const url of urls.slice(0, 3)) {\n  details.push(await firecrawl.firecrawl_scrape({url}));\n}\nreturn {urls, details};\n</code></pre>"},{"location":"sandbox/#v8-sandbox-architecture","title":"V8 Sandbox Architecture","text":""},{"location":"sandbox/#the-thread-boundary-problem","title":"The Thread Boundary Problem","text":"<p>V8 isolates are <code>!Send</code> -- they cannot cross thread boundaries. But PrismGate's backend services (<code>BackendManager</code>, <code>ToolRegistry</code>) live in the main tokio async runtime. The sandbox solves this with a dedicated OS thread and runtime bridge:</p> <pre><code>Main tokio runtime                    Dedicated V8 thread\n  \u2502                                     \u2502\n  \u251c\u2500 execute() called                   \u2502\n  \u2502   \u251c\u2500 Clone Arcs (registry, mgr)     \u2502\n  \u2502   \u251c\u2500 Spawn \"gatemini-sandbox\" \u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502   \u2502   oneshot channel               \u2502\n  \u2502   \u2502                                 \u251c\u2500 Create V8 Runtime\n  \u2502   \u2502                                 \u251c\u2500 Register __call_tool\n  \u2502   \u2502                                 \u251c\u2500 Generate preamble\n  \u2502   \u2502                                 \u251c\u2500 Load user module\n  \u2502   \u2502                                 \u251c\u2500 Execute main()\n  \u2502   \u2502                                 \u2502   \u251c\u2500 JS calls __call_tool()\n  \u2502   \u2502  \u25c0\u2500\u2500 Handle::spawn \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   \u2502   (dispatches to tokio)\n  \u2502   \u251c\u2500 mgr.call_tool() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502   \u2502\n  \u2502   \u251c\u2500 Returns result \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b8\u2502   \u2502\n  \u2502   \u2502                                 \u2502   \u2514\u2500 Continues execution\n  \u2502   \u2502                                 \u251c\u2500 Send result via oneshot\n  \u2502   \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502                                     \u2502 Thread exits\n  \u2514\u2500 Return result\n</code></pre>"},{"location":"sandbox/#runtime-configuration","title":"Runtime Configuration","text":"Parameter Default Purpose <code>timeout</code> 30s Maximum execution time <code>max_heap_size</code> 50 MB V8 heap limit Thread name <code>gatemini-sandbox</code> OS thread identifier"},{"location":"sandbox/#output-handling","title":"Output Handling","text":"<p>Results are truncated to 200,000 characters (configurable via <code>max_output_size</code>) with UTF-8 boundary awareness:</p> <pre><code>output.truncate(output.floor_char_boundary(max_size));\n</code></pre> <p><code>floor_char_boundary</code> ensures truncation doesn't split multi-byte UTF-8 characters, preventing corrupted JSON responses.</p>"},{"location":"sandbox/#bridge-preamble","title":"Bridge Preamble","text":"<p>Source: <code>src/sandbox/bridge.rs</code></p> <p>Before user code executes, PrismGate generates a JavaScript preamble that creates tool accessor objects for every registered backend:</p> <pre><code>// Helper alias for the registered async function\nconst __ct = rustyscript.async_functions['__call_tool'];\n\n// Backend accessor: exa\nconst exa = {\n  web_search_exa: async (args) =&gt; await __ct(\"exa\", \"web_search_exa\", args || {}),\n  find_similar: async (args) =&gt; await __ct(\"exa\", \"find_similar\", args || {}),\n};\n\n// Backend accessor: tavily\nconst tavily = {\n  tavily_search: async (args) =&gt; await __ct(\"tavily\", \"tavily_search\", args || {}),\n};\n\n// Introspection API\nconst __interfaces = {\n  \"exa\": {\n    \"web_search_exa\": { name: \"web_search_exa\", description: \"...\", input_schema: {...} },\n    \"find_similar\": { name: \"find_similar\", description: \"...\", input_schema: {...} },\n  },\n  // ...\n};\n\nfunction __getToolInterface(dotted_name) {\n  const parts = dotted_name.split('.');\n  if (parts.length === 2) {\n    return __interfaces[parts[0]]?.[parts[1]] || null;\n  }\n  // Search all backends for bare tool name\n  for (const backend of Object.values(__interfaces)) {\n    if (backend[dotted_name]) return backend[dotted_name];\n  }\n  return null;\n}\n</code></pre>"},{"location":"sandbox/#identifier-sanitization","title":"Identifier Sanitization","text":"<p>Backend and tool names are sanitized for use as JavaScript identifiers:</p> Input Sanitized Rule <code>exa</code> <code>exa</code> Already valid <code>my-search-backend</code> <code>my_search_backend</code> Hyphens \u2192 underscores <code>123start</code> <code>_123start</code> Leading digit \u2192 prefix underscore <code>has.dots</code> <code>has_dots</code> Dots \u2192 underscores <p>The original names are preserved in the <code>__ct()</code> calls as JSON-escaped strings, so the backend receives the correct name regardless of sanitization.</p>"},{"location":"sandbox/#string-escaping","title":"String Escaping","text":"<p>All backend and tool names in <code>__ct()</code> calls are JSON-escaped via <code>serde_json::to_string()</code>:</p> <pre><code>// Safe: embedded quotes and backslashes are properly escaped\nweb_search: async (args) =&gt; await __ct(\"exa\", \"web_search_exa\", args || {}),\n</code></pre> <p>This prevents injection attacks from malicious tool names.</p>"},{"location":"sandbox/#user-code-wrapping","title":"User Code Wrapping","text":"<p>If the user's code doesn't export a <code>main</code> function, PrismGate wraps it automatically:</p> <p>User writes: <pre><code>const r = await exa.web_search_exa({query: \"test\"});\nreturn r;\n</code></pre></p> <p>PrismGate wraps as: <pre><code>// ... preamble ...\nexport default async function main() {\n  const r = await exa.web_search_exa({query: \"test\"});\n  return r;\n}\n</code></pre></p> <p>If the code already contains <code>export default</code> or <code>export async function main</code>, it's used as-is.</p>"},{"location":"sandbox/#tool-dispatch","title":"Tool Dispatch","text":"<p>When JavaScript calls <code>__ct(backend, tool, args)</code>:</p> <ol> <li>Validate arguments: backend_name and tool_name must be strings</li> <li>Dispatch to tokio: <code>Handle::spawn()</code> bridges back to the main async runtime</li> <li>Call backend: <code>manager.call_tool(backend_name, tool_name, arguments)</code></li> <li>Error enhancement: If the tool exists in the registry but the backend isn't ready, the error message is enhanced:</li> </ol> <pre><code>Backend 'exa' is still starting. Tool 'web_search_exa' is cached\nbut the backend hasn't connected yet. Try again shortly.\n</code></pre> <p>This handles the common case where the tool cache provides tool definitions before all backends have connected.</p>"},{"location":"sandbox/#introspection-api","title":"Introspection API","text":"<p>The sandbox exposes two introspection mechanisms:</p>"},{"location":"sandbox/#__interfaces","title":"<code>__interfaces</code>","text":"<p>A nested object containing full tool schemas grouped by backend. Useful for programmatic schema inspection:</p> <pre><code>const schema = __interfaces.exa.web_search_exa.input_schema;\nconst params = Object.keys(schema.properties);\n</code></pre>"},{"location":"sandbox/#__gettoolinterfacename","title":"<code>__getToolInterface(name)</code>","text":"<p>Look up a tool by dotted notation (<code>backend.tool_name</code>) or bare name:</p> <pre><code>const info = __getToolInterface(\"exa.web_search_exa\");\n// or\nconst info = __getToolInterface(\"web_search_exa\"); // searches all backends\n</code></pre>"},{"location":"sandbox/#security-considerations","title":"Security Considerations","text":"<p>The V8 sandbox inherits Deno's security model through rustyscript:</p> <ul> <li>No filesystem access by default</li> <li>No network access by default</li> <li>No environment variable access by default</li> <li>No subprocess spawning by default</li> </ul> <p>The only capability is calling <code>__call_tool</code>, which is mediated through PrismGate's <code>BackendManager</code>. This provides a controlled execution environment where the TypeScript code can only interact with registered backend tools.</p> <p>The V8 engine also provides in-process sandboxing with ~1% performance overhead, isolating heap memory to prevent memory corruption from spreading.</p>"},{"location":"sandbox/#sources","title":"Sources","text":"<ul> <li><code>src/tools/sandbox.rs</code> -- Three-tier execution strategy</li> <li><code>src/sandbox/mod.rs</code> -- V8 sandbox implementation</li> <li><code>src/sandbox/bridge.rs</code> -- Preamble generation</li> <li>rustyscript -- V8 sandbox wrapper for Rust</li> <li>Deno Security -- Permission model</li> <li>V8 Sandbox -- In-process memory isolation</li> <li>Glama Code Execution -- Token savings from code execution</li> <li>Block Goose: Code Mode + MCP -- Complementary pattern validation</li> <li>E2B Architecture -- Firecracker alternative comparison</li> </ul>"},{"location":"secrets-and-config/","title":"Secrets &amp; Configuration","text":"<p>PrismGate's configuration pipeline transforms YAML config files through environment expansion, secret resolution, and validation into a running daemon with hot-reload support.</p>"},{"location":"secrets-and-config/#configuration-pipeline","title":"Configuration Pipeline","text":"<p>Source: <code>src/config.rs</code></p> <pre><code>1. load_dotenv()           ~/.env loaded via Once pattern (thread-safe)\n         \u2502\n2. YAML parse              serde_yaml_ng with shellexpand\n         \u2502                  $VAR, ${VAR}, ${VAR:-default}, ~\n         \u2502\n3. resolve_secrets_async   secretref: patterns resolved via providers\n         \u2502\n4. validate                Required fields, valid values\n         \u2502\n5. hot-reload watcher      notify crate watches config file\n</code></pre>"},{"location":"secrets-and-config/#stage-1-environment-loading","title":"Stage 1: Environment Loading","text":"<pre><code>static DOTENV_ONCE: std::sync::Once = std::sync::Once::new();\n\npub fn load_dotenv() {\n    DOTENV_ONCE.call_once(|| {\n        dotenvy::dotenv().ok();\n    });\n}\n</code></pre> <p>The <code>Once</code> pattern ensures <code>~/.env</code> is loaded exactly once, even if multiple threads call <code>load_dotenv()</code> concurrently. This prevents UB from <code>std::env::set_var</code> in multi-threaded contexts.</p>"},{"location":"secrets-and-config/#stage-2-yaml-parsing","title":"Stage 2: YAML Parsing","text":"<p>Config values support shell-like expansion via <code>shellexpand</code>:</p> <pre><code>backends:\n  my_backend:\n    command: \"${HOME}/tools/my-server\"    # Environment variable\n    cwd: \"~/projects/my-project\"          # Tilde expansion\n    env:\n      API_KEY: \"${MY_API_KEY}\"            # Env var in nested values\n      FALLBACK: \"${MISSING:-default}\"     # Default value syntax\n</code></pre>"},{"location":"secrets-and-config/#stage-3-secret-resolution","title":"Stage 3: Secret Resolution","text":"<p>See Secret Resolution below.</p>"},{"location":"secrets-and-config/#stage-4-validation","title":"Stage 4: Validation","text":"<ul> <li>Backend names checked for uniqueness</li> <li>Required fields verified (command or url per backend)</li> <li>Transport type validated (Stdio or HTTP)</li> <li>Timeout values checked for sanity</li> </ul>"},{"location":"secrets-and-config/#config-structs","title":"Config Structs","text":"<pre><code># Top-level Config\nlog_level: \"info\"            # tracing log level\ndaemon:\n  idle_timeout: 300          # seconds, 0 = disabled\nhealth:\n  interval: 5                # seconds between health checks\n  timeout: 10                # seconds per ping\n  failure_threshold: 3       # consecutive failures for circuit break\n  max_restarts: 5            # per restart_window\n  restart_window: 300        # seconds\nallow_runtime_registration: true\nmax_dynamic_backends: 10\nsemantic:\n  model_path: null           # custom model2vec path (optional)\nbackends:\n  backend_name:\n    transport: stdio         # or http\n    command: \"...\"           # stdio only\n    args: [...]              # stdio only\n    url: \"...\"               # http only\n    env: {}                  # environment variables\n    headers: {}              # http headers\n    timeout: 30              # seconds per tool call\n    required_keys: []        # env var keys needed\n    prerequisite: {}         # prerequisite process config\n</code></pre>"},{"location":"secrets-and-config/#defaults","title":"Defaults","text":"Field Default <code>log_level</code> <code>\"info\"</code> <code>transport</code> <code>Stdio</code> <code>timeout</code> 30s <code>health.interval</code> 5s <code>health.timeout</code> 10s <code>health.failure_threshold</code> 3 <code>health.max_restarts</code> 5 <code>health.restart_window</code> 5 min <code>daemon.idle_timeout</code> 5 min <code>allow_runtime_registration</code> <code>true</code> <code>max_dynamic_backends</code> 10"},{"location":"secrets-and-config/#secret-resolution","title":"Secret Resolution","text":"<p>Source: <code>src/secrets/resolver.rs</code></p> <p>PrismGate resolves secrets at config load time using a <code>secretref:</code> pattern syntax:</p> <pre><code>secretref:&lt;provider&gt;:&lt;reference&gt;\n</code></pre>"},{"location":"secrets-and-config/#resolution-modes","title":"Resolution Modes","text":"<p>Full value -- entire string is a secretref: <pre><code>env:\n  API_KEY: \"secretref:bws:project/dotenv/key/EXA_API_KEY\"\n</code></pre> Resolved directly: the secret value replaces the entire string.</p> <p>Inline -- secretref embedded in a larger string: <pre><code>headers:\n  Authorization: \"Bearer secretref:bws:project/dotenv/key/MY_TOKEN\"\n</code></pre> Resolved via regex replacement: only the <code>secretref:...</code> portion is replaced.</p>"},{"location":"secrets-and-config/#pattern-matching","title":"Pattern Matching","text":"<pre><code>secretref:([^:\\s]+):([\\w/.\\-]+)\n</code></pre> <ul> <li>Group 1: Provider name (e.g., <code>bws</code>)</li> <li>Group 2: Reference path (e.g., <code>project/dotenv/key/EXA_API_KEY</code>)</li> </ul>"},{"location":"secrets-and-config/#strict-mode","title":"Strict Mode","text":"<p>Empty resolved values are treated as errors. This prevents backends from starting with blank API keys.</p>"},{"location":"secrets-and-config/#where-secrets-are-resolved","title":"Where Secrets Are Resolved","text":"<p>Secrets are resolved in all backend config fields: - <code>env</code> values - <code>headers</code> values - <code>url</code> strings</p>"},{"location":"secrets-and-config/#bitwarden-secrets-manager-bws","title":"Bitwarden Secrets Manager (BWS)","text":"<p>Source: <code>src/secrets/bws.rs</code></p> <p>The BWS provider integrates with Bitwarden Secrets Manager for centralized secret storage:</p>"},{"location":"secrets-and-config/#configuration","title":"Configuration","text":"<pre><code>secrets:\n  bws:\n    access_token: \"${BWS_ACCESS_TOKEN}\"  # or set env var directly\n    org_id: \"${BWS_ORG_ID}\"              # organization ID\n</code></pre>"},{"location":"secrets-and-config/#reference-format","title":"Reference Format","text":"<pre><code>secretref:bws:project/dotenv/key/{VAR_NAME}\n</code></pre> <p>The path format follows BWS's hierarchy: <code>project</code> \u2192 <code>dotenv</code> (collection) \u2192 <code>key</code> \u2192 <code>{VAR_NAME}</code>.</p>"},{"location":"secrets-and-config/#authentication","title":"Authentication","text":"<p>BWS uses machine account access tokens scoped to specific secret sets. The access token is read from config or the <code>$BWS_ACCESS_TOKEN</code> environment variable.</p>"},{"location":"secrets-and-config/#secret-provider-trait","title":"Secret Provider Trait","text":"<p>PrismGate's secret resolution is provider-agnostic through a trait:</p> <pre><code>#[async_trait]\npub trait SecretProvider: Send + Sync {\n    async fn resolve(&amp;self, reference: &amp;str) -&gt; Result&lt;String&gt;;\n}\n</code></pre> <p>This enables adding new providers (e.g., HashiCorp Vault, 1Password, AWS Secrets Manager) without changing the resolution pipeline.</p>"},{"location":"secrets-and-config/#comparison-with-other-tools","title":"Comparison with Other Tools","text":"Tool Pattern Example PrismGate <code>secretref:provider:path</code> <code>secretref:bws:project/dotenv/key/API_KEY</code> 1Password CLI <code>op://vault/item/field</code> <code>op://dev/server/api_key</code> Vault Agent <code>{{ .Data.data.key }}</code> <code>{{ .Data.data.api_key }}</code> K8s External Secrets <code>SecretStore</code> + <code>ExternalSecret</code> YAML resources <p>PrismGate's approach most closely resembles 1Password's URI-based references: config files with secret references can be safely committed to Git, and values are resolved at runtime.</p>"},{"location":"secrets-and-config/#hot-reload","title":"Hot-Reload","text":"<p>Source: <code>src/config.rs</code> -- <code>watch_config()</code></p> <p>PrismGate watches the config file for changes using the <code>notify</code> crate (macOS: kqueue, Linux: inotify):</p> <pre><code>Config file change detected\n    \u2502\n    \u251c\u2500\u2500 Re-parse YAML (shellexpand + serde)\n    \u251c\u2500\u2500 Re-resolve secrets (async)\n    \u251c\u2500\u2500 Diff backends:\n    \u2502   \u251c\u2500\u2500 New backend \u2192 add_backend()\n    \u2502   \u251c\u2500\u2500 Removed backend \u2192 remove_backend()\n    \u2502   \u2514\u2500\u2500 Changed backend \u2192 stop + restart\n    \u2514\u2500\u2500 arc_swap for lock-free config update\n</code></pre>"},{"location":"secrets-and-config/#lock-free-config-swaps","title":"Lock-Free Config Swaps","text":"<p>The config is wrapped in <code>arc_swap::ArcSwap</code>, enabling atomic updates without blocking readers:</p> <pre><code>config_holder.store(Arc::new(new_config));\n</code></pre> <p>Existing references to the old config continue working until dropped. New references see the updated config immediately.</p>"},{"location":"secrets-and-config/#example-configuration","title":"Example Configuration","text":"<pre><code>log_level: info\n\ndaemon:\n  idle_timeout: 300\n\nhealth:\n  interval: 5\n  timeout: 10\n  failure_threshold: 3\n  max_restarts: 5\n  restart_window: 300\n\nsecrets:\n  bws:\n    access_token: \"${BWS_ACCESS_TOKEN}\"\n\nbackends:\n  exa:\n    command: npx\n    args: [\"-y\", \"exa-mcp-server\"]\n    env:\n      EXA_API_KEY: \"secretref:bws:project/dotenv/key/EXA_API_KEY\"\n\n  tavily:\n    command: npx\n    args: [\"-y\", \"tavily-mcp-server\"]\n    env:\n      TAVILY_API_KEY: \"secretref:bws:project/dotenv/key/TAVILY_API_KEY\"\n\n  custom_http:\n    transport: http\n    url: \"https://api.example.com/mcp\"\n    headers:\n      Authorization: \"Bearer secretref:bws:project/dotenv/key/CUSTOM_TOKEN\"\n    timeout: 60\n</code></pre>"},{"location":"secrets-and-config/#sources","title":"Sources","text":"<ul> <li><code>src/config.rs</code> -- Config pipeline, hot-reload</li> <li><code>src/secrets/resolver.rs</code> -- Secret resolution engine</li> <li><code>src/secrets/bws.rs</code> -- Bitwarden integration</li> <li>Bitwarden Secrets Manager -- BWS overview</li> <li>Bitwarden SDK -- Rust SDK reference</li> <li>Bitwarden Access Tokens -- Machine account auth</li> <li>1Password Secret References -- Pattern comparison</li> <li>OWASP Secrets Management -- Best practices</li> <li>shellexpand -- Environment variable expansion</li> <li>notify crate -- File system watcher</li> <li>arc_swap -- Lock-free atomic swaps</li> </ul>"},{"location":"telemetry-strategy/","title":"Telemetry Strategy","text":"<p>This document outlines PrismGate's plan for extracting real effectiveness data using OpenTelemetry with GenAI semantic conventions.</p>"},{"location":"telemetry-strategy/#current-state","title":"Current State","text":"<p>PrismGate already has basic observability through the <code>tracing</code> crate:</p> Capability Implementation Location Structured logging <code>tracing</code> with <code>info!</code>, <code>warn!</code>, <code>error!</code> All modules In-flight call tracking <code>CallGuard</code> RAII counter (AtomicUsize) <code>src/backend/mod.rs</code> Health check state <code>consecutive_failures</code>, <code>restart_count</code>, <code>circuit_open_since</code> <code>src/backend/health.rs</code> Cache operations Load/save event logging with tool counts <code>src/cache.rs</code> Backend lifecycle Start/stop/restart event logging <code>src/backend/mod.rs</code>"},{"location":"telemetry-strategy/#whats-missing","title":"What's Missing","text":"<ul> <li>No token counting -- cannot measure actual token savings from progressive disclosure</li> <li>No call frequency tracking -- don't know which tools agents use most</li> <li>No latency histograms -- no P50/P95/P99 for tool calls or discovery</li> <li>No usage analytics -- can't prove brief mode adoption or discovery patterns</li> <li>No response size tracking -- token savings are estimated, not measured</li> </ul>"},{"location":"telemetry-strategy/#opentelemetry-integration-plan","title":"OpenTelemetry Integration Plan","text":""},{"location":"telemetry-strategy/#phase-1-traces","title":"Phase 1: Traces","text":"<p>Add spans to every tool call and discovery operation:</p> <pre><code>[daemon session]\n  \u251c\u2500\u2500 [search_tools] query=\"web search\" brief=true results=5 response_bytes=340\n  \u251c\u2500\u2500 [tool_info] tool=\"web_search_exa\" detail=\"brief\" response_bytes=120\n  \u251c\u2500\u2500 [tool_info] tool=\"web_search_exa\" detail=\"full\" response_bytes=3200\n  \u2514\u2500\u2500 [call_tool_chain]\n       \u251c\u2500\u2500 [direct_parse] matched=true\n       \u2514\u2500\u2500 [backend.call_tool] backend=\"exa\" tool=\"web_search_exa\" duration_ms=450\n</code></pre> <p>Span attributes following OpenTelemetry GenAI semantic conventions:</p> Attribute Type Example <code>gatemini.tool.name</code> string <code>\"search_tools\"</code> <code>gatemini.tool.backend</code> string <code>\"exa\"</code> <code>gatemini.discovery.mode</code> string <code>\"brief\"</code> or <code>\"full\"</code> <code>gatemini.discovery.result_count</code> int <code>5</code> <code>gatemini.response.size_bytes</code> int <code>3200</code> <code>gatemini.sandbox.execution_mode</code> string <code>\"direct\"</code> or <code>\"v8\"</code>"},{"location":"telemetry-strategy/#phase-2-metrics","title":"Phase 2: Metrics","text":"<p>Key metrics to track, using GenAI conventions where applicable:</p> <p>Discovery Metrics:</p> Metric Type Purpose <code>gatemini.search.requests</code> Counter Total search_tools calls <code>gatemini.search.brief_ratio</code> Gauge % of searches using brief mode <code>gatemini.tool_info.requests</code> Counter Total tool_info calls <code>gatemini.tool_info.brief_ratio</code> Gauge % of tool_info using brief mode <code>gatemini.discovery.depth</code> Histogram Steps before execution (1-4) <code>gatemini.response.size_bytes</code> Histogram Response sizes by tool type <p>Backend Metrics:</p> Metric Type Purpose <code>gatemini.backend.call_duration</code> Histogram Tool call latency by backend <code>gatemini.backend.calls_total</code> Counter Total calls by backend + tool <code>gatemini.backend.errors_total</code> Counter Failed calls by backend + error type <code>gatemini.backend.health_state</code> Gauge Current state (Healthy/Unhealthy/Stopped) <code>gatemini.backend.restarts_total</code> Counter Auto-restart count by backend <code>gatemini.backend.in_flight</code> Gauge Currently active calls <p>Sandbox Metrics:</p> Metric Type Purpose <code>gatemini.sandbox.executions_total</code> Counter Total call_tool_chain invocations <code>gatemini.sandbox.direct_parse_ratio</code> Gauge % resolved without V8 <code>gatemini.sandbox.execution_duration</code> Histogram V8 execution time <code>gatemini.sandbox.heap_usage_bytes</code> Histogram V8 heap consumption"},{"location":"telemetry-strategy/#phase-3-export","title":"Phase 3: Export","text":"<p>OTLP export to configurable backend:</p> <pre><code># gatemini.yaml\ntelemetry:\n  enabled: true\n  otlp_endpoint: \"http://localhost:4317\"  # Jaeger, Grafana, etc.\n  export_interval: 30s\n  service_name: \"gatemini\"\n</code></pre> <p>Compatible with: - Jaeger -- distributed tracing - Grafana Cloud -- MCP-specific dashboards - SigNoz -- open-source observability - Datadog -- LLM + MCP monitoring</p>"},{"location":"telemetry-strategy/#metrics-to-prove-progressive-disclosure-effectiveness","title":"Metrics to Prove Progressive Disclosure Effectiveness","text":"<p>The key question: do agents actually use progressive disclosure, and does it save tokens?</p>"},{"location":"telemetry-strategy/#adoption-metrics","title":"Adoption Metrics","text":"<pre><code>brief_search_count / total_search_count = brief adoption rate\nbrief_tool_info_count / total_tool_info_count = brief adoption rate\n</code></pre> <p>Target: &gt;90% of searches use brief mode, proving the default is effective.</p>"},{"location":"telemetry-strategy/#token-savings-metrics","title":"Token Savings Metrics","text":"<pre><code>actual_response_bytes = sum of all search_tools + tool_info response sizes\ncounterfactual_bytes = result_count * average_full_tool_schema_size\nsavings_ratio = 1 - (actual_response_bytes / counterfactual_bytes)\n</code></pre>"},{"location":"telemetry-strategy/#discovery-depth-distribution","title":"Discovery Depth Distribution","text":"<p>Track the step at which agents execute:</p> <pre><code>1-step: search_tools \u2192 call_tool_chain (agent already knows the tool)\n2-step: search_tools \u2192 tool_info(brief) \u2192 call_tool_chain\n3-step: search_tools \u2192 tool_info(brief) \u2192 tool_info(full) \u2192 call_tool_chain\n4-step: full progressive disclosure flow\n</code></pre> <p>Shallower depth = more efficient discovery = better tool naming and descriptions.</p>"},{"location":"telemetry-strategy/#reference-implementations","title":"Reference Implementations","text":"Project Approach Relevance OpenLLMetry OTel extensions for LLM calls Semantic conventions for AI observability IBM Context Forge OTLP instrumentation for MCP gateway Production MCP gateway telemetry OpenLIT Single-line MCP instrumentation Minimal-effort integration pattern Sentry MCP Automatic span capture for tools Error tracking integration SigNoz MCP Hierarchical span model for agents Span hierarchy design reference"},{"location":"telemetry-strategy/#proposed-span-hierarchy","title":"Proposed Span Hierarchy","text":"<p>Following SigNoz's recommended model:</p> <pre><code>[session]                    -- Per-client daemon connection\n  \u251c\u2500\u2500 [mcp.request]          -- Each MCP JSON-RPC request\n  \u2502   \u251c\u2500\u2500 [discovery]        -- search_tools, tool_info, list_tools_meta\n  \u2502   \u2502   \u251c\u2500\u2500 [bm25_search]  -- BM25 scoring\n  \u2502   \u2502   \u2514\u2500\u2500 [semantic_search]  -- Embedding lookup (if enabled)\n  \u2502   \u251c\u2500\u2500 [tool_call]        -- call_tool_chain\n  \u2502   \u2502   \u251c\u2500\u2500 [parse]        -- Direct parse or V8 sandbox\n  \u2502   \u2502   \u2514\u2500\u2500 [backend.call] -- Actual backend tool invocation\n  \u2502   \u2514\u2500\u2500 [registration]     -- register_manual, deregister_manual\n  \u2514\u2500\u2500 [health_check]         -- Periodic backend pings\n</code></pre>"},{"location":"telemetry-strategy/#implementation-notes","title":"Implementation Notes","text":""},{"location":"telemetry-strategy/#rust-crates","title":"Rust Crates","text":"Crate Purpose <code>opentelemetry</code> Core OTel API <code>opentelemetry-otlp</code> OTLP exporter <code>tracing-opentelemetry</code> Bridge <code>tracing</code> spans to OTel <code>opentelemetry-semantic-conventions</code> Standard attribute names <p>PrismGate already uses <code>tracing</code> throughout, so the integration path is adding a <code>tracing-opentelemetry</code> layer that forwards spans to the OTLP exporter. Existing <code>info!</code>, <code>debug!</code>, and <code>warn!</code> calls become span events automatically.</p>"},{"location":"telemetry-strategy/#minimal-code-changes","title":"Minimal Code Changes","text":"<pre><code>// In src/main.rs initialization:\nlet tracer = opentelemetry_otlp::new_pipeline()\n    .tracing()\n    .with_exporter(opentelemetry_otlp::new_exporter().tonic())\n    .install_batch()?;\n\nlet otel_layer = tracing_opentelemetry::layer().with_tracer(tracer);\n// Add to existing tracing subscriber\n</code></pre> <pre><code>// In tool call handlers:\n#[tracing::instrument(fields(\n    gatemini.tool.name = %tool_name,\n    gatemini.tool.backend = %backend,\n    gatemini.response.size_bytes = tracing::field::Empty,\n))]\n</code></pre>"},{"location":"telemetry-strategy/#sources","title":"Sources","text":"<ul> <li>OpenTelemetry AI Agent Observability -- OTel conventions for AI</li> <li>OTel LLM Observability Introduction -- Foundational reference</li> <li>Datadog MCP Monitoring -- End-to-end MCP tracing</li> <li>Datadog OTel GenAI Conventions -- Standard schema</li> <li>OpenLLMetry -- OTel extensions for LLM calls</li> <li>IBM Context Forge -- MCP gateway with OTLP</li> <li>SigNoz MCP Observability -- Span hierarchy model</li> <li>Grafana MCP Observability -- Dashboard setup</li> <li>Sentry MCP Monitoring -- Automatic instrumentation</li> <li>OpenLIT MCP Quickstart -- Single-line setup</li> <li>FinOps for AI -- 30-200x cost variance</li> <li>VictoriaMetrics AI Observability -- Open-source metrics</li> <li><code>tracing</code> crate -- Rust structured logging</li> <li><code>tracing-opentelemetry</code> -- OTel bridge</li> </ul>"},{"location":"token-efficiency/","title":"Token Efficiency","text":"<p>PrismGate's progressive disclosure system delivers 82-98% token savings compared to exposing tool definitions directly. This document presents measured data from the production tool registry.</p> <p></p>"},{"location":"token-efficiency/#summary","title":"Summary","text":"Feature Without PrismGate With PrismGate Savings <code>search_tools</code> (10 results) ~5,000 tokens ~600 tokens 88% <code>tool_info</code> (single tool) ~10,700 tokens ~200 tokens 98% <code>gatemini://tools</code> compact index ~40,000 tokens ~3,000 tokens 92.5% Typical discovery flow (search + inspect + execute) ~20,000 tokens ~3,600 tokens 82% Meta-tool definitions (7 tools in <code>tools/list</code>) N/A ~1,500 tokens Fixed cost"},{"location":"token-efficiency/#how-we-measure","title":"How We Measure","text":""},{"location":"token-efficiency/#tool-definition-tokens","title":"Tool Definition Tokens","text":"<p>Token counts are estimated from actual JSON output sizes. The relationship between JSON bytes and tokens is approximately 4 characters per token for structured data (JSON schemas, tool descriptions).</p>"},{"location":"token-efficiency/#worst-case-tool","title":"Worst-Case Tool","text":"<p>The largest tool in the production registry is auggie's <code>codebase-retrieval</code>: - Full <code>tool_info</code> response: ~10,700 tokens - Brief <code>tool_info</code> response: ~200 tokens - Reduction: 98.1%</p> <p>Most tools are smaller (200-2,000 tokens for full schemas), making the average reduction even higher.</p>"},{"location":"token-efficiency/#full-registry-cost","title":"Full Registry Cost","text":"<p>With 258 registered tools across 33 backends: - Full tool definitions (all schemas): ~67,000 tokens - This represents 33.5% of Claude's 200k context window - With PrismGate's 7 meta-tools: ~1,500 tokens (2.2% reduction from 33.5%)</p>"},{"location":"token-efficiency/#typical-discovery-flow","title":"Typical Discovery Flow","text":"<p>A representative tool discovery session:</p> <pre><code>Agent task: \"Search the web for MCP best practices\"\n\nStep 1: search_tools(\"web search\", brief=true)\n  \u2192 3 results \u00d7 ~60 tokens = ~180 tokens\n\nStep 2: tool_info(\"web_search_exa\", detail=\"brief\")\n  \u2192 ~200 tokens (name, backend, first sentence, param names)\n\nStep 3: tool_info(\"web_search_exa\", detail=\"full\")\n  \u2192 ~800 tokens (full schema for this specific tool)\n\nStep 4: call_tool_chain(\"exa.web_search_exa({query: '...'})\")\n  \u2192 Execution, not discovery\n</code></pre> <p>Total discovery cost: ~1,180 tokens Without progressive disclosure: ~5,000 tokens (full search) + ~10,700 tokens (full tool_info) = ~15,700 tokens</p>"},{"location":"token-efficiency/#why-82-for-typical-flow","title":"Why 82% for \"Typical Flow\"","text":"<p>The 82% figure accounts for the overhead of PrismGate's meta-tool definitions (~1,500 tokens) being present in every session, plus the multi-step discovery process. For sessions that discover more tools, the savings percentage increases.</p>"},{"location":"token-efficiency/#brief-vs-full-mode-comparison","title":"Brief vs Full Mode Comparison","text":""},{"location":"token-efficiency/#search_tools","title":"search_tools","text":"Mode Per-Result Tokens 10 Results Content Full ~500 ~5,000 name, full description, backend Brief (default) ~60 ~600 name, first sentence, backend"},{"location":"token-efficiency/#tool_info","title":"tool_info","text":"Mode Tokens Content Full 200-10,700 name, full description, backend, complete JSON schema Brief (default) ~200 name, first sentence, backend, parameter names only"},{"location":"token-efficiency/#resources","title":"Resources","text":"Resource Tokens Equivalent <code>gatemini://tools</code> ~3,000 Compact index of all 258 tools Full <code>tools/list</code> ~40,000 All tool definitions Single <code>gatemini://tool/{name}</code> 200-10,000 On-demand full schema"},{"location":"token-efficiency/#industry-comparison","title":"Industry Comparison","text":"<p>PrismGate's approach is validated by multiple independent sources:</p> Source Approach Claimed Savings PrismGate 7 meta-tools + brief/full modes 82-98% Speakeasy Dynamic Toolsets V2 Dynamic tool loading via search 96% input, 90% total Anthropic Tool Search Tool <code>defer_loading: true</code> + search 85% reduction RAG-MCP (arXiv) Retrieval-first schema injection 50%+ prompt tokens ProDisco Progressive disclosure for K8s tools Prevents 30,000-50,000 token overhead Huawei SEP-1576 Schema deduplication via JSON $ref 30-60% <p>PrismGate's savings are consistent with industry benchmarks, particularly Speakeasy's measurements which use a similar progressive search approach.</p>"},{"location":"token-efficiency/#token-savings-remain-constant-at-scale","title":"Token Savings Remain Constant at Scale","text":"<p>A key finding from Speakeasy's research: progressive search uses 1,600-2,500 tokens regardless of whether the toolset has 40 or 400 tools. PrismGate exhibits the same behavior -- the <code>search_tools</code> response size depends on the <code>limit</code> parameter, not the total tool count.</p>"},{"location":"token-efficiency/#cache-system","title":"Cache System","text":"<p>Source: <code>src/cache.rs</code></p> <p>PrismGate's tool cache provides instant tool availability on daemon restart:</p> Aspect Impact Startup latency Tools available immediately from cache; backends connect in background Embedding persistence Semantic vectors saved with cache; no re-encoding on restart Atomic writes Temp file + rename prevents cache corruption on crash Version compatibility Cache v1 (tools only) and v2 (tools + embeddings) supported <p>Cache path is derived as a sibling file to the config: <pre><code>config/gatemini.yaml  \u2192  .gatemini.cache.json\n</code></pre></p>"},{"location":"token-efficiency/#cache-format-v2","title":"Cache Format (v2)","text":"<pre><code>{\n  \"version\": 2,\n  \"backends\": {\n    \"exa\": [{\"name\": \"web_search\", \"description\": \"...\", \"backend_name\": \"exa\", \"input_schema\": {...}}],\n    \"tavily\": [...]\n  },\n  \"embeddings\": {\n    \"web_search\": [0.123, -0.456, ...],\n    \"tavily_search\": [...]\n  }\n}\n</code></pre>"},{"location":"token-efficiency/#methodology-for-ongoing-measurement","title":"Methodology for Ongoing Measurement","text":"<p>To extract real token counts from production usage:</p> <ol> <li>Response size tracking: Add byte counts to tracing spans for each meta-tool response</li> <li>Brief/full mode ratio: Track how often agents use brief vs full mode (proves progressive disclosure adoption)</li> <li>Search result counts: Monitor how many results agents typically request</li> <li>Discovery depth: Track how many steps agents take before executing (1-step, 2-step, 3-step, 4-step)</li> </ol> <p>See Telemetry Strategy for the full observability plan.</p>"},{"location":"token-efficiency/#sources","title":"Sources","text":"<ul> <li><code>src/tools/discovery.rs</code> -- Brief/full mode implementation</li> <li><code>src/resources.rs</code> -- Resource token optimization</li> <li><code>src/cache.rs</code> -- Tool cache persistence</li> <li>Speakeasy Dynamic Toolsets V2 -- 96% reduction benchmark</li> <li>Speakeasy Progressive vs Semantic -- Constant-token behavior at scale</li> <li>Anthropic Advanced Tool Use -- 85% reduction with defer_loading</li> <li>RAG-MCP (arXiv) -- 50%+ prompt token reduction</li> <li>Huawei SEP-1576 -- Schema deduplication analysis</li> <li>Layered.dev Token Tax -- 55k tokens for 58 tools</li> <li>The MCP Tool Trap -- Context window consumption problem</li> <li>FinOps Foundation -- 30-200x cost variance in AI deployments</li> </ul>"},{"location":"tool-discovery/","title":"Tool Discovery","text":"<p>PrismGate implements progressive disclosure to prevent tool definition bloat from consuming the AI agent's context window. Instead of exposing 258+ backend tools directly, it exposes 7 meta-tools that let the agent discover, inspect, and execute backend tools on demand.</p>"},{"location":"tool-discovery/#the-problem","title":"The Problem","text":"<p>With 30+ backends, each exposing 5-20 tools, PrismGate manages 258+ tools. Naive approaches fail at this scale:</p> Approach Token Cost Impact Expose all tools in <code>tools/list</code> ~67,000 tokens 33.7% of 200k context consumed before conversation starts Single tool <code>tool_info</code> response ~10,700 tokens Largest tool (auggie's codebase-retrieval) 10 full search results ~5,000 tokens Half a turn of context for one search <p>Research confirms this is an industry-wide problem. Performance degrades after ~40 tools (Demiliani, 2025), and 5-7 tools is the practical accuracy limit (Jenova AI). PrismGate exposes exactly 7 meta-tools, hitting the optimal range.</p>"},{"location":"tool-discovery/#the-solution-4-step-progressive-disclosure","title":"The Solution: 4-Step Progressive Disclosure","text":"<pre><code>Step 1: search_tools(brief=true)     ~60 tokens/result    \"What tools exist?\"\nStep 2: tool_info(detail=\"brief\")    ~200 tokens           \"Tell me more about this one\"\nStep 3: tool_info(detail=\"full\")     ~200-10,700 tokens    \"Give me the full schema\"\nStep 4: call_tool_chain              Execute                \"Run it\"\n</code></pre> <p>Each step reveals progressively more detail, and the agent can stop at any step. A typical discovery flow uses ~3,600 tokens instead of ~20,000 -- an 82% reduction.</p>"},{"location":"tool-discovery/#meta-tools","title":"Meta-Tools","text":"Tool Purpose Brief Mode <code>search_tools</code> BM25/hybrid search by task description Default: brief=true (~60 tok/result) <code>list_tools_meta</code> Paginated list of all tool names Names only (~3 tok/name) <code>tool_info</code> Full or brief schema for one tool Default: detail=\"brief\" (~200 tok) <code>get_required_keys_for_tool</code> Env var keys a backend needs Key names only <code>call_tool_chain</code> Execute TypeScript calling backend tools N/A <code>register_manual</code> Add a backend at runtime N/A <code>deregister_manual</code> Remove a dynamic backend N/A"},{"location":"tool-discovery/#bm25-search","title":"BM25 Search","text":"<p>Source: <code>src/registry.rs</code></p> <p>PrismGate implements BM25 (Okapi BM25) for keyword-based tool search with standard IR parameters:</p> Parameter Value Purpose k1 1.2 Term frequency saturation -- prevents long descriptions from dominating b 0.75 Document length normalization -- adjusts for varying description lengths"},{"location":"tool-discovery/#tokenization","title":"Tokenization","text":"<p>Text is split on non-alphanumeric characters and lowercased:</p> <pre><code>\"get_current_time\"  \u2192  [\"get\", \"current\", \"time\"]\n\"streamable-http\"   \u2192  [\"streamable\", \"http\"]\n\"Search the WEB\"    \u2192  [\"search\", \"the\", \"web\"]\n</code></pre>"},{"location":"tool-discovery/#name-boost-2x","title":"Name Boost (2x)","text":"<p>Tool names receive a 2x weight by duplicating name tokens in the document representation:</p> <pre><code>let mut tokens = tokenize(&amp;entry.name);    // [\"web\", \"search\"]\nlet name_tokens = tokens.clone();\ntokens.extend(name_tokens);                // [\"web\", \"search\", \"web\", \"search\"]\ntokens.extend(tokenize(&amp;entry.description)); // + description tokens\n</code></pre> <p>This ensures exact name matches rank higher than description-only matches. A query for \"web search\" will rank <code>web_search</code> above a tool that merely mentions searching in its description.</p>"},{"location":"tool-discovery/#scoring-formula","title":"Scoring Formula","text":"<p>For each query term t in document d:</p> <pre><code>IDF(t) = ln((N - df(t) + 0.5) / (df(t) + 0.5) + 1)\n\nTF_norm(t,d) = (tf(t,d) * (k1 + 1)) / (tf(t,d) + k1 * (1 - b + b * |d| / avgdl))\n\nscore(d) = sum(IDF(t) * TF_norm(t,d)) for all t in query\n</code></pre> <p>Results are sorted by score descending, then by name for stable ordering.</p>"},{"location":"tool-discovery/#semantic-search","title":"Semantic Search","text":"<p>Source: <code>src/embeddings.rs</code> (feature-gated: <code>semantic</code>)</p> <p>When compiled with the <code>semantic</code> feature, PrismGate adds vector-based search using model2vec:</p> Property Value Model minishlab/potion-base-8M Parameters 8M (50x smaller than typical sentence transformers) Speed ~500x faster than full transformers on CPU Normalization L2-normalized (dot product = cosine similarity)"},{"location":"tool-discovery/#embedding-text","title":"Embedding Text","text":"<p>Each tool is embedded as the concatenation of its name and description:</p> <pre><code>\"{tool_name} {tool_description}\"\n</code></pre>"},{"location":"tool-discovery/#search","title":"Search","text":"<p>Brute-force cosine similarity over all vectors. At 258 tools, this takes ~5 microseconds -- fast enough that approximate nearest neighbor (ANN) indices like HNSW are unnecessary until ~10,000+ tools.</p>"},{"location":"tool-discovery/#when-semantic-helps","title":"When Semantic Helps","text":"<p>BM25 excels at exact term matching but fails on conceptual queries:</p> Query BM25 Result Semantic Result \"web search\" <code>web_search</code> (exact match) <code>web_search</code> \"find information online\" No match (no shared terms) <code>web_search</code> (conceptual match) \"code analysis\" <code>codebase_retrieval</code> (partial) <code>codebase_retrieval</code> + <code>code_search</code>"},{"location":"tool-discovery/#hybrid-rrf-fusion","title":"Hybrid RRF Fusion","text":"<p>Source: <code>src/registry.rs</code> -- <code>search_hybrid()</code></p> <p>When both BM25 and semantic search are available, PrismGate combines them using Reciprocal Rank Fusion (RRF):</p> <pre><code>RRF_score(tool) = sum(1 / (K + rank_i)) for each retriever i\n</code></pre> <p>where K=60 is the standard IR constant.</p>"},{"location":"tool-discovery/#why-rrf","title":"Why RRF?","text":"<p>BM25 produces scores in the 0-15+ range. Cosine similarity produces 0-1. These scales are incomparable -- you can't just add them. RRF sidesteps this by converting both to rank-based scores:</p> Tool BM25 Score BM25 Rank Cosine Semantic Rank RRF Score web_search 8.3 1 0.92 1 1/(61) + 1/(61) = 0.0328 tavily_search 6.1 2 0.85 3 1/(62) + 1/(63) = 0.0320 find_similar 2.4 3 0.88 2 1/(63) + 1/(62) = 0.0320 <p>The fusion fetches at least 30 candidates from each retriever before ranking to ensure quality results.</p>"},{"location":"tool-discovery/#brief-vs-full-modes","title":"Brief vs Full Modes","text":""},{"location":"tool-discovery/#search_tools","title":"search_tools","text":"<p>Brief (default, ~60 tokens/result): <pre><code>{\"name\": \"web_search_exa\", \"backend\": \"exa\", \"description\": \"Search the web.\"}\n</code></pre></p> <p>Full (~500 tokens/result): <pre><code>{\"name\": \"web_search_exa\", \"backend\": \"exa\", \"description\": \"Search the web using Exa's neural search engine. Returns results with titles, URLs, and optional text content...\"}\n</code></pre></p>"},{"location":"tool-discovery/#tool_info","title":"tool_info","text":"<p>Brief (default, ~200 tokens): <pre><code>{\"name\": \"web_search_exa\", \"backend\": \"exa\", \"description\": \"Search the web.\", \"parameters\": [\"query\", \"num_results\", \"type\"]}\n</code></pre></p> <p>Full (~200-10,700 tokens depending on schema complexity): <pre><code>{\"name\": \"web_search_exa\", \"backend\": \"exa\", \"description\": \"...\", \"input_schema\": {\"type\": \"object\", \"properties\": {\"query\": {\"type\": \"string\", \"description\": \"...\"}, ...}}}\n</code></pre></p>"},{"location":"tool-discovery/#first-sentence-extraction","title":"First Sentence Extraction","text":"<p>Source: <code>src/tools/discovery.rs</code> -- <code>first_sentence()</code></p> <p>Brief mode extracts the first sentence by finding: 1. First <code>.</code> (period + space) 2. First <code>.\\n</code> (period + newline) 3. Trailing <code>.</code> (entire text is one sentence) 4. Truncation at 200 chars with <code>...</code> (no sentence boundary found)</p>"},{"location":"tool-discovery/#parameter-name-extraction","title":"Parameter Name Extraction","text":"<p>Brief <code>tool_info</code> returns parameter names instead of full JSON schemas:</p> <pre><code>fn extract_param_names(schema: &amp;Value) -&gt; Vec&lt;String&gt; {\n    schema.get(\"properties\")\n        .and_then(|p| p.as_object())\n        .map(|obj| obj.keys().cloned().collect())\n        .unwrap_or_default()\n}\n</code></pre> <p>This reduces a typical tool schema from ~500 tokens to ~20 tokens (just the parameter names).</p>"},{"location":"tool-discovery/#mcp-resources-for-discovery","title":"MCP Resources for Discovery","text":"<p>Source: <code>src/resources.rs</code></p> <p>PrismGate also exposes tool information as MCP resources (loaded via <code>@</code> mentions in Claude Code):</p> Resource Tokens Purpose <code>gatemini://tools</code> ~3,000 Compact index of ALL tools (vs ~40,000 for full schemas) <code>gatemini://tool/{name}</code> 200-10,000 Full schema for one tool on demand <code>gatemini://overview</code> ~500 Gateway guide with discovery workflow <p>Resources use an even more aggressive 120-character truncation (vs 200 in discovery tools) for maximum compactness.</p>"},{"location":"tool-discovery/#mcp-prompts-for-guided-discovery","title":"MCP Prompts for Guided Discovery","text":"<p>Source: <code>src/prompts.rs</code></p> Prompt Purpose <code>discover</code> 4-step walkthrough teaching the progressive disclosure pattern <code>find_tool</code> Search + display top 5 matches + full schema for #1 + TypeScript example <code>backend_status</code> Health dashboard showing all backends, status, and tool counts"},{"location":"tool-discovery/#server-instructions","title":"Server Instructions","text":"<p>PrismGate embeds discovery instructions directly in its MCP <code>get_info()</code> response. This teaches AI agents the progressive disclosure workflow before they make their first tool call, without requiring external documentation.</p>"},{"location":"tool-discovery/#sources","title":"Sources","text":"<ul> <li><code>src/registry.rs</code> -- BM25 and RRF hybrid search</li> <li><code>src/embeddings.rs</code> -- Semantic embedding index</li> <li><code>src/tools/discovery.rs</code> -- Brief/full mode handlers</li> <li><code>src/resources.rs</code> -- MCP resource system</li> <li><code>src/prompts.rs</code> -- Guided workflow prompts</li> <li>Okapi BM25 (Wikipedia) -- BM25 algorithm</li> <li>Elastic BM25 guide -- Parameter tuning</li> <li>Azure RRF documentation -- Reciprocal Rank Fusion</li> <li>Model2Vec -- Static embeddings</li> <li>Speakeasy 100x token reduction -- Industry validation</li> <li>Anthropic Advanced Tool Use -- Tool Search Tool pattern</li> <li>RAG-MCP paper (arXiv) -- Academic validation of retrieval-first tool discovery</li> <li>Microsoft Tool-space Interference -- Tool scaling research</li> </ul>"},{"location":"benchmarks/search-quality/","title":"Search Quality Benchmarks","text":"<p>PrismGate's tool discovery uses BM25 keyword search and optional semantic search, combined via Reciprocal Rank Fusion (RRF). This document analyzes search quality, scaling behavior, and validation methodology.</p>"},{"location":"benchmarks/search-quality/#bm25-parameters","title":"BM25 Parameters","text":"<p>PrismGate uses standard Okapi BM25 parameters validated by decades of IR research:</p> Parameter Value Rationale k1 1.2 Term frequency saturation -- standard across Lucene, Elasticsearch, and Tantivy b 0.75 Document length normalization -- standard default; could be lowered for short tool descriptions Name boost 2x Name tokens appear twice in document vector -- ensures exact name matches rank above description-only matches"},{"location":"benchmarks/search-quality/#why-these-parameters-work-for-tool-search","title":"Why These Parameters Work for Tool Search","text":"<p>Tool descriptions are short (10-200 words) and relatively uniform in length. This means:</p> <ul> <li>k1=1.2: Prevents long descriptions from dominating through raw term frequency. A tool mentioning \"search\" 5 times doesn't rank 5x higher than one mentioning it once.</li> <li>b=0.75: Provides moderate length normalization. Tools with longer descriptions aren't penalized too heavily, but very short descriptions get a slight boost.</li> <li>2x name boost: The most important signal for tool search is the tool name itself. <code>web_search</code> should rank above a tool that merely mentions \"search\" in its description.</li> </ul> <p>For collections of very short, uniform documents, Elasticsearch recommends potentially lowering b to 0.5-0.6, since length variation is minimal. This could be explored for PrismGate.</p>"},{"location":"benchmarks/search-quality/#semantic-search-quality","title":"Semantic Search Quality","text":""},{"location":"benchmarks/search-quality/#model-choice-model2vec-potion-base-8m","title":"Model Choice: model2vec potion-base-8M","text":"Property Value Parameters 8M Embedding dimension 256 Size vs full transformers 50x smaller Speed vs full transformers 500x faster on CPU Method Vocabulary distillation + PCA + Zipf weighting <p>model2vec distills sentence transformer models by passing the vocabulary through the transformer, reducing dimensionality with PCA, and applying Zipf weighting to counteract high-frequency word bias. This produces static embeddings that can be looked up in O(1) per token rather than running transformer inference.</p> <p>For tool discovery, the tradeoff is optimal: semantic understanding of \"find information online\" \u2192 \"web search\" doesn't require full transformer fidelity, but it does require sub-millisecond latency.</p>"},{"location":"benchmarks/search-quality/#normalization","title":"Normalization","text":"<p>All vectors are L2-normalized in-place after encoding:</p> <pre><code>// L2 normalization: ||v|| = 1, so dot product = cosine similarity\nlet norm = v.iter().map(|x| x * x).sum::&lt;f32&gt;().sqrt();\nfor x in v.iter_mut() { *x /= norm; }\n</code></pre> <p>With normalized vectors, cosine similarity reduces to dot product, which is computationally cheaper (no division needed at query time).</p>"},{"location":"benchmarks/search-quality/#rrf-fusion-validation","title":"RRF Fusion Validation","text":""},{"location":"benchmarks/search-quality/#score-scale-problem","title":"Score Scale Problem","text":"<p>BM25 and cosine similarity produce incomparable scores:</p> Retriever Score Range Distribution BM25 0 to ~15+ Unbounded, IDF-dependent Cosine similarity -1 to 1 (0 to 1 with L2 norm) Bounded <p>Simple linear combination (e.g., <code>0.5*BM25 + 0.5*cosine</code>) requires careful weight tuning. RRF avoids this entirely by operating on rank positions:</p> <pre><code>RRF(d) = sum(1 / (K + rank_i(d))) for each retriever i\n</code></pre>"},{"location":"benchmarks/search-quality/#why-k60","title":"Why K=60?","text":"<p>K=60 is the standard constant from the original RRF paper, used in production by Azure AI Search, OpenSearch, and others. The constant controls how quickly scores decay with rank:</p> Rank Score (K=60) Score (K=1) 1 0.0164 0.5000 2 0.0161 0.3333 3 0.0159 0.2500 10 0.0143 0.0909 30 0.0111 0.0323 <p>K=60 produces a gradual decay, giving weight to results ranked deep in each list. K=1 would heavily favor top-ranked results from each retriever.</p>"},{"location":"benchmarks/search-quality/#candidate-pool","title":"Candidate Pool","text":"<p>PrismGate fetches at least 30 candidates from each retriever before fusion:</p> <pre><code>let fetch_limit = limit.max(30);\n</code></pre> <p>This ensures the RRF has enough candidates from both retrievers to produce high-quality merged results, even when the final <code>limit</code> is small (e.g., 5).</p>"},{"location":"benchmarks/search-quality/#scaling-analysis","title":"Scaling Analysis","text":""},{"location":"benchmarks/search-quality/#brute-force-cosine-at-scale","title":"Brute-Force Cosine at Scale","text":"<p>At 258 tools, brute-force cosine similarity takes ~5 microseconds. How does this scale?</p> Tool Count Estimated Time Approach 258 ~5 us Brute-force (current) 1,000 ~20 us Brute-force (sufficient) 5,000 ~100 us Brute-force (still fast) 10,000 ~200 us Consider HNSW index 100,000 ~2 ms HNSW required <p>With 256-dimensional vectors and modern CPUs utilizing SIMD, brute-force remains practical up to ~10,000 tools. Beyond that, approximate nearest neighbor (ANN) indices like HNSW become worthwhile.</p> <p>PrismGate's current tool count (258) is well within the brute-force regime. Even scaling to 1,000 tools would add negligible latency.</p>"},{"location":"benchmarks/search-quality/#bm25-scaling","title":"BM25 Scaling","text":"<p>BM25 scoring is O(n * q) where n = number of tools and q = number of query terms. With short queries (2-5 terms) and 258 tools, this is ~1,000 operations -- trivially fast. At 10,000 tools, it would be ~50,000 operations, still sub-millisecond.</p> <p>For very large registries (100,000+ tools), an inverted index (as in Tantivy) would be needed to avoid scanning all documents for each query.</p>"},{"location":"benchmarks/search-quality/#evaluation-metrics","title":"Evaluation Metrics","text":""},{"location":"benchmarks/search-quality/#recommended-metrics","title":"Recommended Metrics","text":"Metric Formula Best For MRR (Mean Reciprocal Rank) Average of 1/rank of first relevant result Tool search (agent usually uses top result) nDCG@5 Normalized Discounted Cumulative Gain at rank 5 Comparing retrieval quality Recall@5 Fraction of relevant tools in top 5 results Ensuring relevant tools aren't missed <p>MRR is the most appropriate primary metric for PrismGate because agents typically act on the first relevant tool found (Galileo MRR guide).</p>"},{"location":"benchmarks/search-quality/#proposed-test-harness","title":"Proposed Test Harness","text":"<p>To systematically evaluate search quality:</p> <pre><code>struct SearchBenchmark {\n    /// Natural language query\n    query: String,\n    /// Expected relevant tool names (ground truth)\n    relevant_tools: Vec&lt;String&gt;,\n}\n\nlet benchmarks = vec![\n    SearchBenchmark {\n        query: \"search the web\".to_string(),\n        relevant_tools: vec![\"web_search_exa\", \"tavily_search\"],\n    },\n    SearchBenchmark {\n        query: \"find information online\".to_string(),  // conceptual query\n        relevant_tools: vec![\"web_search_exa\", \"tavily_search\"],\n    },\n    // ... 50+ test cases\n];\n</code></pre> <p>Benchmark categories:</p> <ol> <li>Exact match: Query terms appear in tool name (BM25 should excel)</li> <li>Conceptual match: Synonyms, paraphrases (semantic should excel)</li> <li>Multi-term: Complex queries combining multiple concepts (hybrid should excel)</li> <li>Ambiguous: Queries matching multiple tools (ranking quality matters)</li> </ol>"},{"location":"benchmarks/search-quality/#synthetic-registry-scaling-test","title":"Synthetic Registry Scaling Test","text":"<pre><code>For registry_size in [100, 258, 500, 1000, 5000]:\n  1. Generate synthetic tools (name + description)\n  2. Insert into registry\n  3. Run benchmark queries\n  4. Measure: latency (P50/P95/P99), MRR, nDCG@5\n  5. Compare BM25-only vs semantic-only vs hybrid\n</code></pre>"},{"location":"benchmarks/search-quality/#academic-context","title":"Academic Context","text":"<p>PrismGate's search architecture is validated by recent academic work:</p> Paper Key Finding Relevance RAG-MCP (arXiv) RAG-MCP triples tool selection accuracy (43.13% vs 13.62% baseline) Validates retrieval-first tool discovery Tool-to-Agent Retrieval 19.4% improvement in Recall@5 via unified embedding space Validates semantic search for tools ToolLLM (ICLR 2024) 16,464 APIs organized with DFSDT planning Large-scale tool discovery reference Hybrid search recall 53.4% passage recall vs BM25's 22.1% Quantifies hybrid improvement PCA-RAG (arXiv) PCA can reduce embeddings from 3,072 to 110 dims with moderate quality loss Validates model2vec's PCA approach"},{"location":"benchmarks/search-quality/#sources","title":"Sources","text":"<ul> <li><code>src/registry.rs</code> -- BM25 and RRF implementation</li> <li><code>src/embeddings.rs</code> -- Semantic embedding index</li> <li>Okapi BM25 (Wikipedia) -- BM25 algorithm</li> <li>Elastic BM25 Variables -- Parameter tuning</li> <li>Elastic BM25 Parameter Selection -- Short document considerations</li> <li>Azure Hybrid Search RRF -- RRF reference</li> <li>OpenSearch RRF -- RRF implementation</li> <li>Assembled RRF -- Score normalization problem</li> <li>Model2Vec -- Static embeddings</li> <li>Model2Vec HuggingFace -- potion model family</li> <li>Tantivy -- Rust full-text search alternative</li> <li>Weaviate Evaluation Metrics -- IR metric guide</li> <li>Pinecone Evaluation -- MRR, nDCG, MAP</li> <li>Galileo MRR -- MRR for AI evaluation</li> </ul>"},{"location":"benchmarks/token-savings/","title":"Token Savings Benchmarks","text":"<p>Real measurements from PrismGate's production tool registry with 258 tools across 33 backends.</p>"},{"location":"benchmarks/token-savings/#measurement-methodology","title":"Measurement Methodology","text":""},{"location":"benchmarks/token-savings/#token-estimation","title":"Token Estimation","text":"<p>Token counts are estimated from JSON output sizes. For structured data (JSON schemas, tool definitions), the ratio is approximately 4 characters per token. This is consistent across Claude and GPT model families for JSON content.</p>"},{"location":"benchmarks/token-savings/#test-configuration","title":"Test Configuration","text":"<ul> <li>258 registered tools across 33 backends</li> <li>Tool schemas ranging from simple (2 parameters) to complex (20+ parameters with nested objects)</li> <li>Largest tool: auggie's <code>codebase-retrieval</code> (~10,700 tokens full schema)</li> <li>Smallest tools: ~200 tokens full schema</li> </ul>"},{"location":"benchmarks/token-savings/#operation-level-measurements","title":"Operation-Level Measurements","text":""},{"location":"benchmarks/token-savings/#search_tools","title":"search_tools","text":"Mode Per-Result 5 Results 10 Results Full (brief=false) ~500 tokens ~2,500 ~5,000 Brief (brief=true, default) ~60 tokens ~300 ~600 Savings 88% 88% 88% <p>Brief mode achieves constant 88% savings because it consistently strips the same information: full description \u2192 first sentence, full schema \u2192 omitted.</p>"},{"location":"benchmarks/token-savings/#tool_info","title":"tool_info","text":"Mode Min Median Max (auggie) Full (detail=\"full\") ~200 ~1,500 ~10,700 Brief (detail=\"brief\", default) ~150 ~200 ~250 Savings 25% 87% 98% <p>The savings are most dramatic for complex tools with large schemas. Simple tools (2-3 parameters) see smaller but still meaningful savings.</p>"},{"location":"benchmarks/token-savings/#list_tools_meta","title":"list_tools_meta","text":"Approach Tokens Full tools/list (all schemas) ~67,000 list_tools_meta (names only, 50/page) ~150 per page Savings &gt;99% per page"},{"location":"benchmarks/token-savings/#gateminitools-resource","title":"gatemini://tools Resource","text":"Approach Tokens Full tools/list (all schemas) ~40,000* gatemini://tools (compact index) ~3,000 Savings 92.5% <p>*Note: ~40,000 tokens represents full descriptions without schemas. With schemas, the full cost is ~67,000 tokens.</p>"},{"location":"benchmarks/token-savings/#workflow-level-measurements","title":"Workflow-Level Measurements","text":""},{"location":"benchmarks/token-savings/#typical-discovery-flow","title":"Typical Discovery Flow","text":"<pre><code>Agent discovers and uses one tool:\n\nsearch_tools(\"web search\", brief=true, limit=5)  \u2192  ~300 tokens\ntool_info(\"web_search_exa\", detail=\"brief\")       \u2192  ~200 tokens\ntool_info(\"web_search_exa\", detail=\"full\")         \u2192  ~800 tokens\n                                                      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal discovery cost                               \u2192 ~1,300 tokens\n</code></pre> <p>Without progressive disclosure: Loading the tool via tools/list would cost the agent the full tools/list response (~67,000 tokens) or at minimum finding the right tool schema (~5,000 tokens from full search + ~10,700 from full tool_info).</p>"},{"location":"benchmarks/token-savings/#multi-tool-discovery","title":"Multi-Tool Discovery","text":"<pre><code>Agent discovers and uses three tools:\n\nsearch_tools(\"search and analyze\", brief=true, limit=10)  \u2192  ~600 tokens\ntool_info(\"web_search_exa\", detail=\"brief\")                \u2192  ~200 tokens\ntool_info(\"tavily_search\", detail=\"brief\")                 \u2192  ~200 tokens\ntool_info(\"firecrawl_scrape\", detail=\"brief\")              \u2192  ~200 tokens\ntool_info(\"web_search_exa\", detail=\"full\")                 \u2192  ~800 tokens\ntool_info(\"firecrawl_scrape\", detail=\"full\")               \u2192  ~1,200 tokens\n                                                              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTotal discovery cost                                       \u2192 ~3,200 tokens\n</code></pre> <p>Without progressive disclosure: ~15,700+ tokens for three tools.</p>"},{"location":"benchmarks/token-savings/#session-level-cost","title":"Session-Level Cost","text":"Component Tokens Note Meta-tool definitions (7 tools) ~1,500 Fixed cost per session Server instructions ~500 Teaches discovery workflow Typical discovery (1-3 tools) ~1,300-3,200 Variable Total session overhead ~3,300-5,200 vs ~67,000+ without PrismGate"},{"location":"benchmarks/token-savings/#beforeafter-comparison-table","title":"Before/After Comparison Table","text":"Scenario Without PrismGate With PrismGate Savings Tool definitions in context 67,000 tokens (258 tools) 1,500 tokens (7 meta-tools) 97.8% Find one tool by search 5,000 (full search) 300 (brief search) 94% Inspect one tool 10,700 (worst case) 200 (brief) 98.1% Complete discovery flow 15,700+ 1,300-3,200 80-92% Tool awareness (index) 40,000 (descriptions) 3,000 (compact resource) 92.5%"},{"location":"benchmarks/token-savings/#industry-comparison","title":"Industry Comparison","text":"System Approach Reported Savings Method PrismGate 7 meta-tools + brief/full 82-98% Measured from production registry Speakeasy Dynamic Toolsets V2 Dynamic tool loading 96% input tokens Benchmark across 40-400 tools Anthropic Tool Search defer_loading + search 85% tool token reduction Measured on Claude API RAG-MCP Retrieval-first injection 50%+ prompt tokens Academic benchmark ProDisco Progressive K8s discovery Prevents 30-50k overhead Estimated from K8s tools Huawei SEP-1576 JSON $ref deduplication 30-60% schema tokens Analyzed GitHub MCP server <p>PrismGate's results are consistent with or better than industry benchmarks. The key insight from Speakeasy's research: token usage remains constant regardless of total tool count. PrismGate exhibits the same behavior.</p>"},{"location":"benchmarks/token-savings/#savings-at-scale","title":"Savings at Scale","text":"<p>One of progressive disclosure's strongest properties is that savings increase with tool count:</p> Total Tools Full List Cost PrismGate Cost Savings 50 ~13,000 tokens ~1,500 + ~1,300 78% 100 ~26,000 tokens ~1,500 + ~1,300 89% 258 (current) ~67,000 tokens ~1,500 + ~1,300 96% 500 ~130,000 tokens ~1,500 + ~1,300 98% 1,000 ~260,000 tokens ~1,500 + ~1,300 99% <p>The meta-tool and discovery costs are fixed regardless of backend count. This is the fundamental advantage of the gateway architecture.</p>"},{"location":"benchmarks/token-savings/#ongoing-monitoring","title":"Ongoing Monitoring","text":"<p>To continuously validate these measurements, PrismGate should track:</p> <ol> <li>Response size per meta-tool call -- Add <code>response_bytes</code> to tracing spans</li> <li>Brief/full mode ratio -- Track <code>discovery.mode</code> attribute per call</li> <li>Discovery depth -- Count steps between search and execute per session</li> <li>Cache hit rate -- Track how often cached tools avoid re-discovery</li> </ol> <p>See Telemetry Strategy for the full observability plan.</p>"},{"location":"benchmarks/token-savings/#sources","title":"Sources","text":"<ul> <li><code>src/tools/discovery.rs</code> -- Brief/full mode implementation</li> <li><code>src/resources.rs</code> -- Resource token optimization</li> <li><code>src/cache.rs</code> -- Tool cache for instant availability</li> <li>Speakeasy Dynamic Toolsets V2 -- 96% reduction</li> <li>Speakeasy Constant-Token Behavior -- Scale independence</li> <li>Anthropic Advanced Tool Use -- 85% reduction</li> <li>RAG-MCP -- Academic benchmark</li> <li>Layered.dev Token Tax -- 55k tokens for 58 tools</li> <li>Demiliani 40+ Tool Degradation -- Performance cliff</li> <li>Jenova 5-7 Tool Limit -- Accuracy sweet spot</li> <li>The MCP Tool Trap -- Context window consumption</li> <li>IETF Token-Efficient Draft -- Standards-track validation</li> </ul>"},{"location":"references/competing-gateways/","title":"Competing MCP Gateways","text":"<p>Comparison of PrismGate with other MCP and AI gateways, based on research via deepwiki queries and web search.</p>"},{"location":"references/competing-gateways/#overview","title":"Overview","text":"Gateway Architecture Transport Tool Discovery Sandbox Open Source PrismGate Unix daemon + proxies Stdio + HTTP BM25 + semantic hybrid V8 TypeScript Yes Kong AI Plugin-based proxy HTTP N/A (plugin routing) No Partial Envoy AI Sidecar proxy HTTP N/A (session routing) No Yes Microsoft K8s dual-plane HTTP Tool Gateway Router No Yes Lasso Security gateway HTTP N/A (pass-through) No Yes IBM Context Forge Federated registry HTTP OTLP-instrumented No Yes"},{"location":"references/competing-gateways/#detailed-comparison","title":"Detailed Comparison","text":""},{"location":"references/competing-gateways/#prismgate-gatemini","title":"PrismGate (gatemini)","text":"<p>Architecture: Shared daemon process managing all backends via Unix domain sockets. Multiple Claude Code sessions connect through lightweight proxy processes.</p> <p>Differentiators: - Progressive disclosure: 7 meta-tools + brief/full modes (82-98% token savings) - BM25 + semantic hybrid search: Combines keyword and conceptual matching with RRF fusion - V8 TypeScript sandbox: Multi-tool orchestration in a single execution context - Local-machine optimization: Unix domain sockets (30-66% lower latency than TCP) - Tool cache: Instant availability on restart without re-discovery</p> <p>Trade-offs: - Local-only (no remote/cloud deployment) - Single-machine scaling (no horizontal distribution) - Designed for developer workstation use with Claude Code</p> <p>Source: GitHub</p>"},{"location":"references/competing-gateways/#kong-ai-gateway","title":"Kong AI Gateway","text":"<p>Architecture: Plugin-based API gateway with AI-specific extensions. The AI-Proxy plugin routes MCP traffic to multiple LLM providers.</p> <p>Key features: - <code>llm_format</code> field with provider-specific routing logic - <code>preserve</code> mode for direct SDK passthrough (no transformation) - ACL features for per-tool access control - OAuth 2.1 implementation for MCP authentication - Protocol bridge: converts REST APIs into MCP tools</p> <p>Differentiators: - Enterprise-grade with existing Kong infrastructure integration - Multi-provider LLM routing (OpenAI, Anthropic, Mistral, etc.) - Production-hardened rate limiting and authentication</p> <p>Trade-offs: - No progressive tool discovery - Requires Kong infrastructure - Commercial licensing for full features</p> <p>Source: Kong MCP Blog</p>"},{"location":"references/competing-gateways/#envoy-ai-gateway","title":"Envoy AI Gateway","text":"<p>Architecture: Sidecar proxy using token-encoding for session management. Session state is encrypted into the client session ID rather than stored centrally.</p> <p>Key features: - Stateless session management: Client-encoded session IDs contain multiple backend session references - MCPProxy: Multiplexes by initializing parallel upstream sessions - Configurable encryption (tunable latency: 1-2ms at low security to tens of ms at high security) - No central session store needed (horizontal scaling without shared state) - All core MCP features: tool calls, notifications, prompts, resources</p> <p>Differentiators: - Horizontal scaling without shared state (session info encoded in client ID) - Leverages Envoy's existing proxy infrastructure - ~1-2ms per-session overhead with tuned encryption</p> <p>Trade-offs: - No tool discovery optimization - Session encoding adds per-request latency - Requires Envoy infrastructure</p> <p>Sources: Envoy AI Gateway MCP, Tetrate Performance</p>"},{"location":"references/competing-gateways/#microsoft-mcp-gateway","title":"Microsoft MCP Gateway","text":"<p>Architecture: Kubernetes-native with separate Control Plane and Data Plane.</p> <p>Key features: - Control Plane: RESTful APIs for tool registration and lifecycle management - Data Plane: Runtime traffic routing with session affinity - StatefulSets: Tool adapters deployed as Kubernetes StatefulSets with ClusterIP services - Tool Gateway Router: Specialized pods maintaining tool awareness, using HttpToolExecutor for forwarding - Two routing modes: direct adapter access and tool gateway routing</p> <p>Differentiators: - Full Kubernetes-native deployment model - Separation of control and data planes - Session-aware stateful routing to specialized pods</p> <p>Trade-offs: - Requires Kubernetes infrastructure - Significant operational complexity (StatefulSets, services, routing rules) - No token optimization or progressive disclosure - Enterprise-focused, not developer workstation</p> <p>Source: GitHub</p>"},{"location":"references/competing-gateways/#lasso-security-mcp-gateway","title":"Lasso Security MCP Gateway","text":"<p>Architecture: Security-first gateway with plugin-based guardrail system.</p> <p>Key features: - BasicGuardrailPlugin: Regex patterns for secret masking - LassoGuardrailPlugin: External AI safety API integration with fail-open semantics - PresidioGuardrailPlugin: Microsoft Presidio for PII detection - Intercepts both requests and responses (bidirectional filtering) - Plugin architecture for custom guardrails</p> <p>Differentiators: - First security-centric MCP gateway (launched April 2025) - PII detection and secret masking built-in - AI safety API integration for prompt injection detection - Fail-open semantics (safety check failures don't block traffic)</p> <p>Trade-offs: - Security focus, not tool discovery optimization - No progressive disclosure or token savings - Requires external AI safety APIs for full functionality</p> <p>Source: GitHub</p>"},{"location":"references/competing-gateways/#ibm-context-forge","title":"IBM Context Forge","text":"<p>Architecture: Federated gateway that aggregates multiple peer gateways into a unified registry.</p> <p>Key features: - Federation: Multiple gateways auto-discover and merge registries - Redis-backed syncing: Multi-cluster deployments with consistent state - Virtual Servers: Logical tool bundling across federated servers - OTLP instrumentation: Full OpenTelemetry support for traces, metrics, and logs - Token usage and cost tracking - REST and MCP service federation</p> <p>Differentiators: - Multi-cluster federation (unique in the MCP gateway space) - Built-in observability with OTLP - Virtual servers for logical tool grouping - LLM-specific metrics (token usage, costs)</p> <p>Trade-offs: - Requires Redis for federation - Complex multi-cluster setup - No progressive disclosure or tool search optimization</p> <p>Source: GitHub</p>"},{"location":"references/competing-gateways/#feature-comparison-matrix","title":"Feature Comparison Matrix","text":"Feature PrismGate Kong Envoy Microsoft Lasso IBM Progressive disclosure Yes No No No No No Token optimization 82-98% No No No No No Hybrid search (BM25+semantic) Yes No No No No No Code execution sandbox V8 No No No No No Tool cache Yes No No No No No Circuit breaker Yes Yes Yes Yes No Yes Health checks Yes Yes Yes Yes No Yes Hot-reload config Yes Yes Yes No No Yes Secret management BWS Vault N/A K8s Secrets N/A N/A PII detection No No No No Yes No Federation No No No No No Yes OTLP telemetry Planned Yes No No No Yes Horizontal scaling No Yes Yes Yes No Yes Auth (OAuth/JWT) No Yes No No No Yes Multi-LLM routing No Yes No No No No"},{"location":"references/competing-gateways/#architectural-patterns","title":"Architectural Patterns","text":""},{"location":"references/competing-gateways/#session-management","title":"Session Management","text":"Gateway Approach Statefulness PrismGate Per-client daemon connection Stateful (daemon manages sessions) Kong Plugin-based Stateless (plugin per-request) Envoy Token-encoded session ID Stateless (session in client ID) Microsoft StatefulSet pods Stateful (K8s affinity) Lasso Pass-through Stateless IBM Redis-backed Stateful (Redis store)"},{"location":"references/competing-gateways/#deployment-model","title":"Deployment Model","text":"Gateway Target Environment Scaling PrismGate Developer workstation Single-machine, shared daemon Kong Cloud/on-prem API gateway Horizontal (Kong clustering) Envoy Cloud-native sidecar Horizontal (Envoy mesh) Microsoft Kubernetes cluster Horizontal (K8s scaling) Lasso Cloud security layer Single instance IBM Multi-cluster enterprise Horizontal (Redis federation)"},{"location":"references/competing-gateways/#where-prismgate-fits","title":"Where PrismGate Fits","text":"<p>PrismGate occupies a unique niche: local-machine MCP gateway optimized for AI agent context efficiency. While other gateways focus on cloud deployment, authentication, or security, PrismGate focuses on the developer experience problem of managing 30+ MCP tools without overwhelming the AI agent's context window.</p> <p>The progressive disclosure system, hybrid search, and V8 sandbox are capabilities no other gateway provides. However, PrismGate is intentionally local-only -- it's not designed for cloud deployment, multi-tenant access, or horizontal scaling. For those needs, Kong (enterprise), Envoy (cloud-native), or IBM (federated) are better choices.</p>"},{"location":"references/competing-gateways/#sources","title":"Sources","text":"<ul> <li>Kong AI Gateway -- Kong MCP architecture</li> <li>Envoy AI Gateway -- Session encoding</li> <li>Envoy Performance -- Latency benchmarks</li> <li>Microsoft MCP Gateway -- K8s dual-plane</li> <li>Lasso MCP Gateway -- Security guardrails</li> <li>IBM Context Forge -- Federated gateways</li> <li>MCP Gateway Comparison (Moesif) -- Feature comparison</li> <li>MCP Gateways Explained -- Gateway overview</li> <li>MCP Server vs Gateway -- When to use each</li> <li>Awesome MCP Gateways -- Curated list</li> <li>Centralizing AI Tool Access (AIM) -- Market analysis</li> </ul>"},{"location":"references/mcp-best-practices/","title":"MCP Best Practices Reference","text":"<p>Curated external research on building effective MCP servers, organized by topic. Sources include official MCP documentation, industry blog posts, academic papers, and competing implementations.</p>"},{"location":"references/mcp-best-practices/#token-efficiency-progressive-disclosure","title":"Token Efficiency &amp; Progressive Disclosure","text":""},{"location":"references/mcp-best-practices/#speakeasy-dynamic-toolsets-v2","title":"Speakeasy: Dynamic Toolsets V2","text":"<ul> <li>URL: https://www.speakeasy.com/blog/how-we-reduced-token-usage-by-100x-dynamic-toolsets-v2</li> <li>Key finding: Dynamic Toolset approach reduces token usage by 96% for inputs and 90% for total consumption. Up to 160x reduction while maintaining 100% success rates.</li> <li>Relevance: Validates PrismGate's <code>search_tools</code> + <code>tool_info</code> meta-tool pattern.</li> </ul>"},{"location":"references/mcp-best-practices/#speakeasy-progressive-discovery-vs-semantic-search","title":"Speakeasy: Progressive Discovery vs Semantic Search","text":"<ul> <li>URL: https://www.speakeasy.com/blog/100x-token-reduction-dynamic-toolsets</li> <li>Key finding: Progressive search uses 1,600-2,500 tokens regardless of toolset size (40-400 tools). Token usage remains constant as tools scale.</li> <li>Relevance: Confirms PrismGate's hybrid BM25+semantic approach achieves similar constant-token behavior.</li> </ul>"},{"location":"references/mcp-best-practices/#speakeasy-dynamic-tool-discovery-in-mcp","title":"Speakeasy: Dynamic Tool Discovery in MCP","text":"<ul> <li>URL: https://www.speakeasy.com/mcp/tool-design/dynamic-tool-discovery</li> <li>Key finding: Adding a separate <code>describe_tools</code> function reduces token usage since input schemas represent the largest portion.</li> <li>Relevance: Mirrors PrismGate's two-tier approach: <code>search_tools</code> for discovery, <code>tool_info</code> for schemas.</li> </ul>"},{"location":"references/mcp-best-practices/#anthropic-advanced-tool-use","title":"Anthropic: Advanced Tool Use","text":"<ul> <li>URL: https://www.anthropic.com/engineering/advanced-tool-use</li> <li>Key finding: <code>defer_loading: true</code> enables the Tool Search Tool. Only 3-5 most relevant tools are expanded. Up to 85% reduction; accuracy improves from 79.5% to 88.1%.</li> <li>Relevance: Official Anthropic validation of PrismGate's architecture.</li> </ul>"},{"location":"references/mcp-best-practices/#anthropic-tool-search-tool-documentation","title":"Anthropic: Tool Search Tool Documentation","text":"<ul> <li>URL: https://platform.claude.com/docs/en/agents-and-tools/tool-use/tool-search-tool</li> <li>Key finding: Keep 3-5 tools always loaded, defer the rest. API returns <code>tool_reference</code> blocks automatically expanded.</li> <li>Relevance: PrismGate's 7 meta-tools serve as the always-loaded set.</li> </ul>"},{"location":"references/mcp-best-practices/#layereddev-schema-bloat-token-tax","title":"Layered.dev: Schema Bloat Token Tax","text":"<ul> <li>URL: https://layered.dev/mcp-tool-schema-bloat-the-hidden-token-tax-and-how-to-fix-it/</li> <li>Key finding: A five-server setup with 58 tools consumes approximately 55K tokens before conversation starts.</li> <li>Relevance: Quantifies the problem PrismGate solves.</li> </ul>"},{"location":"references/mcp-best-practices/#rag-mcp-academic-paper","title":"RAG-MCP Academic Paper","text":"<ul> <li>URL: https://arxiv.org/abs/2505.03275</li> <li>Key finding: RAG-MCP triples tool selection accuracy (43.13% vs 13.62%) and reduces prompt tokens by 50%+.</li> <li>Relevance: Academic validation of retrieval-first tool discovery.</li> </ul>"},{"location":"references/mcp-best-practices/#huawei-sep-1576-schema-redundancy","title":"Huawei SEP-1576: Schema Redundancy","text":"<ul> <li>URL: https://github.com/modelcontextprotocol/modelcontextprotocol/issues/1576</li> <li>Key finding: 60% of GitHub MCP server tools share identical field definitions. JSON <code>$ref</code> deduplication can cut 30-60%.</li> <li>Relevance: Complementary optimization PrismGate could add to full-mode responses.</li> </ul>"},{"location":"references/mcp-best-practices/#prodisco-progressive-disclosure-for-kubernetes","title":"ProDisco: Progressive Disclosure for Kubernetes","text":"<ul> <li>URL: https://github.com/harche/ProDisco</li> <li>Key finding: Indexes APIs for discovery, agents search + execute in sandbox. Prevents 30,000-50,000 token overhead.</li> <li>Relevance: Validates PrismGate's search+sandbox pattern.</li> </ul>"},{"location":"references/mcp-best-practices/#meta-tool-pattern-bounded-context-packs","title":"Meta-Tool Pattern: Bounded Context Packs","text":"<ul> <li>URL: https://blog.synapticlabs.ai/bounded-context-packs-meta-tool-pattern</li> <li>Key finding: Meta-tools serve as the discovery interface, exposing searchTools and getTypeDefinitions instead of hundreds of narrow tools.</li> <li>Relevance: PrismGate's 7 meta-tools are a production implementation of this pattern.</li> </ul>"},{"location":"references/mcp-best-practices/#progressive-disclosure-in-agentic-workflows","title":"Progressive Disclosure in Agentic Workflows","text":"<ul> <li>URL: https://medium.com/@prakashkop054/s01-mcp03-progressive-disclosure-for-knowledge-discovery-in-agentic-workflows-8fc0b2840d01</li> <li>Key finding: Two-stage discovery (minimal \u2192 full) achieves 96% token reduction in typical workflows.</li> <li>Relevance: Mirrors PrismGate's brief/full discovery modes.</li> </ul>"},{"location":"references/mcp-best-practices/#progressive-tool-discovery-pattern","title":"Progressive Tool Discovery Pattern","text":"<ul> <li>URL: https://agentic-patterns.com/patterns/progressive-tool-discovery/</li> <li>Key finding: Recognized agentic pattern that scales to hundreds or thousands of tools.</li> <li>Relevance: PrismGate is a production implementation.</li> </ul>"},{"location":"references/mcp-best-practices/#tool-scaling-selection","title":"Tool Scaling &amp; Selection","text":""},{"location":"references/mcp-best-practices/#microsoft-tool-space-interference","title":"Microsoft: Tool-space Interference","text":"<ul> <li>URL: https://www.microsoft.com/en-us/research/blog/tool-space-interference-in-the-mcp-era-designing-for-agent-compatibility-at-scale/</li> <li>Key finding: 1,500 MCP servers analyzed. Tool name collisions, semantic overlap, and long response context degrade performance. OpenAI recommends &lt;20 tools.</li> <li>Relevance: PrismGate's namespaced registry prevents tool-space interference.</li> </ul>"},{"location":"references/mcp-best-practices/#demiliani-too-many-tools-problem","title":"Demiliani: Too Many Tools Problem","text":"<ul> <li>URL: https://demiliani.com/2025/09/04/model-context-protocol-and-the-too-many-tools-problem/</li> <li>Key finding: Performance degrades after ~40 tools, falls off a cliff after 60. Cursor limits to 40 MCP tools.</li> <li>Relevance: PrismGate's 7 meta-tools stay well within the accuracy threshold.</li> </ul>"},{"location":"references/mcp-best-practices/#jenova-ai-tool-overload","title":"Jenova: AI Tool Overload","text":"<ul> <li>URL: https://www.jenova.ai/en/resources/mcp-tool-scalability-problem</li> <li>Key finding: 5-7 tools is the practical upper limit for consistent accuracy. RAG-MCP approach triples accuracy.</li> <li>Relevance: PrismGate exposes exactly 7 meta-tools.</li> </ul>"},{"location":"references/mcp-best-practices/#the-mcp-tool-trap","title":"The MCP Tool Trap","text":"<ul> <li>URL: https://jentic.com/blog/the-mcp-tool-trap</li> <li>Key finding: Tool descriptions consume context needed for reasoning and task memory. Too many leads to hallucinated parameters.</li> <li>Relevance: PrismGate's meta-tool architecture addresses this directly.</li> </ul>"},{"location":"references/mcp-best-practices/#tool-to-agent-retrieval","title":"Tool-to-Agent Retrieval","text":"<ul> <li>URL: https://arxiv.org/abs/2511.01854</li> <li>Key finding: 19.4% Recall@5 improvement via unified embedding space. MCP-specific LiveMCPBench benchmark.</li> <li>Relevance: Academic validation of embedding-based tool search.</li> </ul>"},{"location":"references/mcp-best-practices/#toolllm-iclr-2024","title":"ToolLLM (ICLR 2024)","text":"<ul> <li>URL: https://arxiv.org/abs/2307.16789</li> <li>Key finding: 16,464 APIs organized in tree structure with DFSDT planning. Foundational large-scale tool discovery paper.</li> <li>Relevance: Validates the need for structured tool discovery at scale.</li> </ul>"},{"location":"references/mcp-best-practices/#mcp-protocol-primitives","title":"MCP Protocol &amp; Primitives","text":""},{"location":"references/mcp-best-practices/#mcp-specification-2025-11-25","title":"MCP Specification (2025-11-25)","text":"<ul> <li>URL: https://modelcontextprotocol.io/specification/2025-11-25</li> <li>Key finding: Official spec defining tools/list, tools/call, pagination, listChanged notifications, and three primitives.</li> <li>Relevance: PrismGate implements all three MCP primitives.</li> </ul>"},{"location":"references/mcp-best-practices/#mcp-resources-concept","title":"MCP Resources Concept","text":"<ul> <li>URL: https://modelcontextprotocol.info/docs/concepts/resources/</li> <li>Key finding: Resources are application-controlled data. Templates use URI patterns for dynamic content.</li> <li>Relevance: PrismGate's resource system provides @-mention discovery.</li> </ul>"},{"location":"references/mcp-best-practices/#workos-mcp-features-guide","title":"WorkOS MCP Features Guide","text":"<ul> <li>URL: https://workos.com/blog/mcp-features-guide</li> <li>Key finding: Comprehensive guide to tools, resources, prompts, sampling, roots, and elicitation.</li> <li>Relevance: Reference for PrismGate's multi-primitive approach.</li> </ul>"},{"location":"references/mcp-best-practices/#laurent-kubaski-stdio-transport","title":"Laurent Kubaski: Stdio Transport","text":"<ul> <li>URL: https://medium.com/@laurentkubaski/understanding-mcp-stdio-transport-protocol-ae3d5daf64db</li> <li>Key finding: Client launches server as subprocess. Newline-delimited messages on stdin/stdout.</li> <li>Relevance: PrismGate's proxy mode bridges this protocol.</li> </ul>"},{"location":"references/mcp-best-practices/#mcp-message-types-portkey","title":"MCP Message Types (Portkey)","text":"<ul> <li>URL: https://portkey.ai/blog/mcp-message-types-complete-json-rpc-reference-guide/</li> <li>Key finding: JSON-RPC 2.0 with requests, notifications, and results. Transport-agnostic.</li> <li>Relevance: PrismGate bridges JSON-RPC over Unix domain sockets.</li> </ul>"},{"location":"references/mcp-best-practices/#codesignal-mcp-primitives","title":"CodeSignal: MCP Primitives","text":"<ul> <li>URL: https://codesignal.com/learn/courses/developing-and-integrating-a-mcp-server-in-python/lessons/exploring-and-exposing-mcp-server-capabilities-tools-resources-and-prompts</li> <li>Key finding: Tools are model-driven, Resources are application-driven, Prompts are user-driven.</li> <li>Relevance: PrismGate implements all three control patterns.</li> </ul>"},{"location":"references/mcp-best-practices/#search-retrieval","title":"Search &amp; Retrieval","text":""},{"location":"references/mcp-best-practices/#okapi-bm25-wikipedia","title":"Okapi BM25 (Wikipedia)","text":"<ul> <li>URL: https://en.wikipedia.org/wiki/Okapi_BM25</li> <li>Key finding: Standard k1=1.2, b=0.75 parameters. Bag-of-words retrieval function.</li> <li>Relevance: PrismGate's BM25 implementation uses these parameters.</li> </ul>"},{"location":"references/mcp-best-practices/#elastic-bm25-algorithm-variables","title":"Elastic: BM25 Algorithm Variables","text":"<ul> <li>URL: https://www.elastic.co/blog/practical-bm25-part-2-the-bm25-algorithm-and-its-variables</li> <li>Key finding: k1 limits term frequency impact. b controls length normalization.</li> <li>Relevance: Parameter tuning guidance for PrismGate's tool descriptions.</li> </ul>"},{"location":"references/mcp-best-practices/#elastic-picking-b-and-k1","title":"Elastic: Picking b and k1","text":"<ul> <li>URL: https://www.elastic.co/blog/practical-bm25-part-3-considerations-for-picking-b-and-k1-in-elasticsearch</li> <li>Key finding: Defaults work for most corpora. Short documents may benefit from lower b.</li> <li>Relevance: PrismGate's tool descriptions are short and uniform.</li> </ul>"},{"location":"references/mcp-best-practices/#azure-reciprocal-rank-fusion","title":"Azure: Reciprocal Rank Fusion","text":"<ul> <li>URL: https://learn.microsoft.com/en-us/azure/search/hybrid-search-ranking</li> <li>Key finding: RRF score = 1/(rank + k), k=60. Handles disparate scoring ranges without tuning.</li> <li>Relevance: PrismGate's hybrid search uses RRF with K=60.</li> </ul>"},{"location":"references/mcp-best-practices/#model2vec","title":"Model2Vec","text":"<ul> <li>URL: https://github.com/MinishLab/model2vec</li> <li>Key finding: 50x size reduction, 500x faster. Vocabulary distillation + PCA + Zipf weighting.</li> <li>Relevance: Powers PrismGate's semantic search.</li> </ul>"},{"location":"references/mcp-best-practices/#hybrid-search-recall","title":"Hybrid Search Recall","text":"<ul> <li>URL: https://medium.com/thinking-sand/hybrid-search-with-bm25-and-rank-fusion-for-accurate-results-456a70305dc5</li> <li>Key finding: Hybrid achieves 53.4% passage recall vs BM25's 22.1%.</li> <li>Relevance: Quantifies the benefit of PrismGate's hybrid approach.</li> </ul>"},{"location":"references/mcp-best-practices/#observability-telemetry","title":"Observability &amp; Telemetry","text":""},{"location":"references/mcp-best-practices/#opentelemetry-ai-agent-observability","title":"OpenTelemetry: AI Agent Observability","text":"<ul> <li>URL: https://opentelemetry.io/docs/specs/semconv/gen-ai/</li> <li>Key finding: Standard schema for tracking prompts, model responses, token usage, tool calls.</li> <li>Relevance: Target standard for PrismGate's telemetry.</li> </ul>"},{"location":"references/mcp-best-practices/#datadog-mcp-client-monitoring","title":"Datadog: MCP Client Monitoring","text":"<ul> <li>URL: https://www.datadoghq.com/blog/mcp-client-monitoring/</li> <li>Key finding: End-to-end tracing of MCP lifecycle with automatic span capture.</li> <li>Relevance: Target observability model.</li> </ul>"},{"location":"references/mcp-best-practices/#openllmetry","title":"OpenLLMetry","text":"<ul> <li>URL: https://github.com/traceloop/openllmetry</li> <li>Key finding: OTel extensions for LLM calls. Conventions merged into OpenTelemetry standard.</li> <li>Relevance: Reference implementation for AI observability.</li> </ul>"},{"location":"references/mcp-best-practices/#sentry-mcp-server-monitoring","title":"Sentry: MCP Server Monitoring","text":"<ul> <li>URL: https://blog.sentry.io/introducing-mcp-server-monitoring/</li> <li>Key finding: Single line of code for full MCP observability. Automatic span capture.</li> <li>Relevance: Integration target for PrismGate.</li> </ul>"},{"location":"references/mcp-best-practices/#security-secrets","title":"Security &amp; Secrets","text":""},{"location":"references/mcp-best-practices/#owasp-secrets-management-cheat-sheet","title":"OWASP: Secrets Management Cheat Sheet","text":"<ul> <li>URL: https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html</li> <li>Key finding: Provide SDKs, CLI for local dev, self-service workflows. Audit access.</li> <li>Relevance: Best practices for PrismGate's secret management.</li> </ul>"},{"location":"references/mcp-best-practices/#1password-secret-references","title":"1Password: Secret References","text":"<ul> <li>URL: https://developer.1password.com/docs/cli/secret-references/</li> <li>Key finding: URI-based references (op://vault/item/field). Config files with references safe to commit.</li> <li>Relevance: Pattern comparison for PrismGate's secretref: syntax.</li> </ul>"},{"location":"references/mcp-best-practices/#bitwarden-secrets-manager-sdk","title":"Bitwarden: Secrets Manager SDK","text":"<ul> <li>URL: https://bitwarden.com/help/secrets-manager-sdk/</li> <li>Key finding: Rust-based SDK with machine account authentication.</li> <li>Relevance: PrismGate's BWS integration foundation.</li> </ul>"},{"location":"references/mcp-best-practices/#code-execution-sandboxing","title":"Code Execution &amp; Sandboxing","text":""},{"location":"references/mcp-best-practices/#glama-code-execution-with-mcp","title":"Glama: Code Execution with MCP","text":"<ul> <li>URL: https://glama.ai/blog/2025-12-14-code-execution-with-mcp-architecting-agentic-efficiency</li> <li>Key finding: Code execution reduces token consumption by batching operations in a single context.</li> <li>Relevance: Validates <code>call_tool_chain</code> architecture.</li> </ul>"},{"location":"references/mcp-best-practices/#block-goose-code-mode-mcp","title":"Block Goose: Code Mode + MCP","text":"<ul> <li>URL: https://block.github.io/goose/blog/2025/12/21/code-mode-doesnt-replace-mcp/</li> <li>Key finding: Code execution and MCP are complementary, not competing approaches.</li> <li>Relevance: Validates PrismGate's combined meta-tool + sandbox design.</li> </ul>"},{"location":"references/mcp-best-practices/#v8-sandbox","title":"V8 Sandbox","text":"<ul> <li>URL: https://v8.dev/blog/sandbox</li> <li>Key finding: In-process memory isolation with ~1% performance overhead.</li> <li>Relevance: Security foundation for PrismGate's TypeScript execution.</li> </ul>"},{"location":"references/mcp-best-practices/#deno-security","title":"Deno Security","text":"<ul> <li>URL: https://docs.deno.com/runtime/fundamentals/security/</li> <li>Key finding: No filesystem, network, env, or subprocess access by default.</li> <li>Relevance: PrismGate's sandbox inherits these restrictions.</li> </ul>"},{"location":"references/mcp-best-practices/#process-management-ipc","title":"Process Management &amp; IPC","text":""},{"location":"references/mcp-best-practices/#baeldung-ipc-performance","title":"Baeldung: IPC Performance","text":"<ul> <li>URL: https://www.baeldung.com/linux/ipc-performance-comparison</li> <li>Key finding: Unix domain sockets deliver 30-66% lower latency and 7x throughput vs TCP.</li> <li>Relevance: Validates PrismGate's UDS choice.</li> </ul>"},{"location":"references/mcp-best-practices/#flock2-man-page","title":"flock(2) Man Page","text":"<ul> <li>URL: https://man7.org/linux/man-pages/man2/flock.2.html</li> <li>Key finding: LOCK_EX for exclusive lock, LOCK_NB for non-blocking. Auto-released on process exit.</li> <li>Relevance: PrismGate's daemon coordination mechanism.</li> </ul>"},{"location":"references/mcp-best-practices/#process-group-kill","title":"Process Group Kill","text":"<ul> <li>URL: https://www.baeldung.com/linux/kill-members-process-group</li> <li>Key finding: kill(-pgid, signal) terminates all group members. setpgid(0,0) creates new group.</li> <li>Relevance: PrismGate's backend process isolation.</li> </ul>"},{"location":"references/mcp-best-practices/#aws-circuit-breaker-pattern","title":"AWS: Circuit Breaker Pattern","text":"<ul> <li>URL: https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/circuit-breaker.html</li> <li>Key finding: Closed \u2192 Open \u2192 Half-Open states. Prevents cascading failures.</li> <li>Relevance: PrismGate's health checker implements this pattern.</li> </ul>"},{"location":"references/mcp-best-practices/#aws-exponential-backoff-with-jitter","title":"AWS: Exponential Backoff with Jitter","text":"<ul> <li>URL: https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter/</li> <li>Key finding: Jitter prevents thundering herd on retries.</li> <li>Relevance: PrismGate uses exponential backoff for restarts.</li> </ul>"},{"location":"references/mcp-best-practices/#rust-dependencies","title":"Rust Dependencies","text":""},{"location":"references/mcp-best-practices/#dashmap","title":"DashMap","text":"<ul> <li>URL: https://github.com/xacrimon/dashmap</li> <li>Key finding: Lock-free concurrent HashMap with per-shard RwLocks.</li> <li>Relevance: PrismGate's tool registry and backend storage.</li> </ul>"},{"location":"references/mcp-best-practices/#rmcp","title":"rmcp","text":"<ul> <li>URL: https://github.com/4t145/rmcp</li> <li>Key finding: Rust MCP SDK with tokio async, stdio/HTTP transports.</li> <li>Relevance: PrismGate's core MCP protocol implementation.</li> </ul>"},{"location":"references/mcp-best-practices/#rustyscript","title":"rustyscript","text":"<ul> <li>URL: https://github.com/rscarson/rustyscript</li> <li>Key finding: Deno-based V8 sandbox for Rust. TypeScript transpilation, sandboxed by default.</li> <li>Relevance: PrismGate's call_tool_chain execution engine.</li> </ul>"},{"location":"references/mcp-best-practices/#tantivy","title":"Tantivy","text":"<ul> <li>URL: https://github.com/quickwit-oss/tantivy</li> <li>Key finding: Full-text search engine in Rust with BM25. Alternative for large-scale search.</li> <li>Relevance: Potential upgrade path for PrismGate's search at 10,000+ tools.</li> </ul>"},{"location":"references/mcp-best-practices/#standards-specifications","title":"Standards &amp; Specifications","text":""},{"location":"references/mcp-best-practices/#ietf-token-efficient-agentic-communication","title":"IETF: Token-Efficient Agentic Communication","text":"<ul> <li>URL: https://datatracker.ietf.org/doc/draft-chang-agent-token-efficient/</li> <li>Key finding: IETF draft proposing Agentic Data Object Layer (ADOL) to eliminate redundant definitions.</li> <li>Relevance: Standards-track validation of the token efficiency problem.</li> </ul>"},{"location":"references/mcp-best-practices/#mcp-schema-reference","title":"MCP Schema Reference","text":"<ul> <li>URL: https://modelcontextprotocol.io/specification/draft/schema</li> <li>Key finding: Official JSON schema definitions for MCP messages.</li> <li>Relevance: PrismGate's protocol compliance baseline.</li> </ul>"},{"location":"references/mcp-best-practices/#mcp-transports-specification","title":"MCP Transports Specification","text":"<ul> <li>URL: https://modelcontextprotocol.info/specification/draft/basic/transports/</li> <li>Key finding: Stdio (newline-delimited) and HTTP (Streamable HTTP + SSE) transports.</li> <li>Relevance: PrismGate supports both transport types.</li> </ul>"}]}